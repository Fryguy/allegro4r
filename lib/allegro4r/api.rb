# Generated by ffi_gen. Please do not change this file by hand.

require 'ffi'

module Allegro4r::API
  extend FFI::Library
  ffi_lib_flags :now
  ffi_lib "allegro", "allegro_font", "allegro_image", "allegro_dialog", "allegro_primitives"

  def self.attach_function(name, *_)
    begin; super; rescue FFI::NotFoundError => e
      (class << self; self; end).class_eval { define_method(name) { |*_| raise e } }
    end
  end

  ALLEGRO_VERSION = 5

  ALLEGRO_SUB_VERSION = 0

  ALLEGRO_WIP_VERSION = 11

  ALLEGRO_RELEASE_NUMBER = 1

  ALLEGRO_VERSION_STR = "5.0.11"

  ALLEGRO_DATE_STR = "2015"

  ALLEGRO_DATE = 20150111

  ALLEGRO_PI = 3.14159265358979323846

  ALLEGRO_NATIVE_PATH_SEP = '/'

  ALLEGRO_NATIVE_DRIVE_SEP = '\0'

  def allegro_debug_channel(x)

  end

  def allegro_trace_level(x)
    allegro_trace_channel_level(AL_DEBUG_CHANNEL, x)
  end

  def allegro_assert_concat(a, b)
    allegro_assert_concat(a, b)
  end

  def allegro_get_event_type(a, b, c, d)
    al_id(a, b, c, d)
  end

  EOF = (-1)

  AL_MAX_JOYSTICK_AXES = 3

  AL_MAX_JOYSTICK_STICKS = 8

  AL_MAX_JOYSTICK_BUTTONS = 32

  ALLEGRO_MOUSE_MAX_EXTRA_AXES = 4

  def al_init()
    (al_install_system(ALLEGRO_VERSION_INT, ATEXIT))
  end

  ALLEGRO_VERTEX_CACHE_SIZE = 256

  ALLEGRO_PRIM_QUALITY = 10

  # (Not documented)
  #
  # @method al_get_allegro_version()
  # @return [Integer]
  # @scope class
  attach_function :al_get_allegro_version, :al_get_allegro_version, [], :uint

  # (Not documented)
  #
  # @method al_run_main(argc, argv, )
  # @param [Integer] argc
  # @param [FFI::Pointer(**CharS)] argv
  # @param [FFI::Pointer(*)]
  # @return [Integer]
  # @scope class
  attach_function :al_run_main, :al_run_main, [:int, :pointer, :pointer], :int, :blocking => true

  # (Not documented)
  #
  # = Fields:
  # :pad1 ::
  #   (Integer)
  # :pad2 ::
  #   (Integer)
  class AllegroTimeout < FFI::Struct
    layout :pad1, :ulong_long,
           :pad2, :ulong_long
  end

  # (Not documented)
  #
  # @method al_get_time()
  # @return [Float]
  # @scope class
  attach_function :al_get_time, :al_get_time, [], :double

  # (Not documented)
  #
  # @method al_rest(seconds)
  # @param [Float] seconds
  # @return [nil]
  # @scope class
  attach_function :al_rest, :al_rest, [:double], :void

  # (Not documented)
  #
  # @method al_init_timeout(timeout, seconds)
  # @param [AllegroTimeout] timeout
  # @param [Float] seconds
  # @return [nil]
  # @scope class
  attach_function :al_init_timeout, :al_init_timeout, [AllegroTimeout, :double], :void

  # (Not documented)
  #
  # = Fields:
  # :r ::
  #   (Float)
  # :g ::
  #   (Float)
  # :b ::
  #   (Float)
  # :a ::
  #   (Float)
  class AllegroColor < FFI::Struct
    layout :r, :float,
           :g, :float,
           :b, :float,
           :a, :float
  end

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_pixel_format).</em>
  #
  # === Options:
  # :allegro_pixel_format_any ::
  #
  # :allegro_pixel_format_any_no_alpha ::
  #
  # :allegro_pixel_format_any_with_alpha ::
  #
  # :allegro_pixel_format_any_15_no_alpha ::
  #
  # :allegro_pixel_format_any_16_no_alpha ::
  #
  # :allegro_pixel_format_any_16_with_alpha ::
  #
  # :allegro_pixel_format_any_24_no_alpha ::
  #
  # :allegro_pixel_format_any_32_no_alpha ::
  #
  # :allegro_pixel_format_any_32_with_alpha ::
  #
  # :allegro_pixel_format_argb_8888 ::
  #
  # :allegro_pixel_format_rgba_8888 ::
  #
  # :allegro_pixel_format_argb_4444 ::
  #
  # :allegro_pixel_format_rgb_888 ::
  #
  # :allegro_pixel_format_rgb_565 ::
  #   24 bit format
  # :allegro_pixel_format_rgb_555 ::
  #
  # :allegro_pixel_format_rgba_5551 ::
  #
  # :allegro_pixel_format_argb_1555 ::
  #
  # :allegro_pixel_format_abgr_8888 ::
  #
  # :allegro_pixel_format_xbgr_8888 ::
  #
  # :allegro_pixel_format_bgr_888 ::
  #
  # :allegro_pixel_format_bgr_565 ::
  #   24 bit format
  # :allegro_pixel_format_bgr_555 ::
  #
  # :allegro_pixel_format_rgbx_8888 ::
  #
  # :allegro_pixel_format_xrgb_8888 ::
  #
  # :allegro_pixel_format_abgr_f32 ::
  #
  # :allegro_pixel_format_abgr_8888_le ::
  #
  # :allegro_pixel_format_rgba_4444 ::
  #
  # :allegro_num_pixel_formats ::
  #
  #
  # @method _enum_allegro_pixel_format_
  # @return [Symbol]
  # @scope class
  enum :allegro_pixel_format, [
    :allegro_pixel_format_any, 0,
    :allegro_pixel_format_any_no_alpha, 1,
    :allegro_pixel_format_any_with_alpha, 2,
    :allegro_pixel_format_any_15_no_alpha, 3,
    :allegro_pixel_format_any_16_no_alpha, 4,
    :allegro_pixel_format_any_16_with_alpha, 5,
    :allegro_pixel_format_any_24_no_alpha, 6,
    :allegro_pixel_format_any_32_no_alpha, 7,
    :allegro_pixel_format_any_32_with_alpha, 8,
    :allegro_pixel_format_argb_8888, 9,
    :allegro_pixel_format_rgba_8888, 10,
    :allegro_pixel_format_argb_4444, 11,
    :allegro_pixel_format_rgb_888, 12,
    :allegro_pixel_format_rgb_565, 13,
    :allegro_pixel_format_rgb_555, 14,
    :allegro_pixel_format_rgba_5551, 15,
    :allegro_pixel_format_argb_1555, 16,
    :allegro_pixel_format_abgr_8888, 17,
    :allegro_pixel_format_xbgr_8888, 18,
    :allegro_pixel_format_bgr_888, 19,
    :allegro_pixel_format_bgr_565, 20,
    :allegro_pixel_format_bgr_555, 21,
    :allegro_pixel_format_rgbx_8888, 22,
    :allegro_pixel_format_xrgb_8888, 23,
    :allegro_pixel_format_abgr_f32, 24,
    :allegro_pixel_format_abgr_8888_le, 25,
    :allegro_pixel_format_rgba_4444, 26,
    :allegro_num_pixel_formats, 27
  ]

  # (Not documented)
  #
  # @method al_map_rgb(r, g, b)
  # @param [Integer] r
  # @param [Integer] g
  # @param [Integer] b
  # @return [AllegroColor]
  # @scope class
  attach_function :al_map_rgb, :al_map_rgb, [:uchar, :uchar, :uchar], AllegroColor.by_value

  # (Not documented)
  #
  # @method al_map_rgba(r, g, b, a)
  # @param [Integer] r
  # @param [Integer] g
  # @param [Integer] b
  # @param [Integer] a
  # @return [AllegroColor]
  # @scope class
  attach_function :al_map_rgba, :al_map_rgba, [:uchar, :uchar, :uchar, :uchar], AllegroColor.by_value

  # (Not documented)
  #
  # @method al_map_rgb_f(r, g, b)
  # @param [Float] r
  # @param [Float] g
  # @param [Float] b
  # @return [AllegroColor]
  # @scope class
  attach_function :al_map_rgb_f, :al_map_rgb_f, [:float, :float, :float], AllegroColor.by_value

  # (Not documented)
  #
  # @method al_map_rgba_f(r, g, b, a)
  # @param [Float] r
  # @param [Float] g
  # @param [Float] b
  # @param [Float] a
  # @return [AllegroColor]
  # @scope class
  attach_function :al_map_rgba_f, :al_map_rgba_f, [:float, :float, :float, :float], AllegroColor.by_value

  # (Not documented)
  #
  # @method al_unmap_rgb(color, r, g, b)
  # @param [AllegroColor] color
  # @param [FFI::Pointer(*Uchar)] r
  # @param [FFI::Pointer(*Uchar)] g
  # @param [FFI::Pointer(*Uchar)] b
  # @return [nil]
  # @scope class
  attach_function :al_unmap_rgb, :al_unmap_rgb, [AllegroColor.by_value, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_unmap_rgba(color, r, g, b, a)
  # @param [AllegroColor] color
  # @param [FFI::Pointer(*Uchar)] r
  # @param [FFI::Pointer(*Uchar)] g
  # @param [FFI::Pointer(*Uchar)] b
  # @param [FFI::Pointer(*Uchar)] a
  # @return [nil]
  # @scope class
  attach_function :al_unmap_rgba, :al_unmap_rgba, [AllegroColor.by_value, :pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_unmap_rgb_f(color, r, g, b)
  # @param [AllegroColor] color
  # @param [FFI::Pointer(*Float)] r
  # @param [FFI::Pointer(*Float)] g
  # @param [FFI::Pointer(*Float)] b
  # @return [nil]
  # @scope class
  attach_function :al_unmap_rgb_f, :al_unmap_rgb_f, [AllegroColor.by_value, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_unmap_rgba_f(color, r, g, b, a)
  # @param [AllegroColor] color
  # @param [FFI::Pointer(*Float)] r
  # @param [FFI::Pointer(*Float)] g
  # @param [FFI::Pointer(*Float)] b
  # @param [FFI::Pointer(*Float)] a
  # @return [nil]
  # @scope class
  attach_function :al_unmap_rgba_f, :al_unmap_rgba_f, [AllegroColor.by_value, :pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_get_pixel_size(format)
  # @param [Integer] format
  # @return [Integer]
  # @scope class
  attach_function :al_get_pixel_size, :al_get_pixel_size, [:int], :int

  # (Not documented)
  #
  # @method al_get_pixel_format_bits(format)
  # @param [Integer] format
  # @return [Integer]
  # @scope class
  attach_function :al_get_pixel_format_bits, :al_get_pixel_format_bits, [:int], :int

  # (Not documented)
  #
  # @method al_set_new_bitmap_format(format)
  # @param [Integer] format
  # @return [nil]
  # @scope class
  attach_function :al_set_new_bitmap_format, :al_set_new_bitmap_format, [:int], :void

  # (Not documented)
  #
  # @method al_set_new_bitmap_flags(flags)
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_set_new_bitmap_flags, :al_set_new_bitmap_flags, [:int], :void

  # (Not documented)
  #
  # @method al_get_new_bitmap_format()
  # @return [Integer]
  # @scope class
  attach_function :al_get_new_bitmap_format, :al_get_new_bitmap_format, [], :int

  # (Not documented)
  #
  # @method al_get_new_bitmap_flags()
  # @return [Integer]
  # @scope class
  attach_function :al_get_new_bitmap_flags, :al_get_new_bitmap_flags, [], :int

  # (Not documented)
  #
  # @method al_add_new_bitmap_flag(flag)
  # @param [Integer] flag
  # @return [nil]
  # @scope class
  attach_function :al_add_new_bitmap_flag, :al_add_new_bitmap_flag, [:int], :void

  # (Not documented)
  #
  # @method al_get_bitmap_width(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Integer]
  # @scope class
  attach_function :al_get_bitmap_width, :al_get_bitmap_width, [:pointer], :int

  # (Not documented)
  #
  # @method al_get_bitmap_height(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Integer]
  # @scope class
  attach_function :al_get_bitmap_height, :al_get_bitmap_height, [:pointer], :int

  # (Not documented)
  #
  # @method al_get_bitmap_format(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Integer]
  # @scope class
  attach_function :al_get_bitmap_format, :al_get_bitmap_format, [:pointer], :int

  # (Not documented)
  #
  # @method al_get_bitmap_flags(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Integer]
  # @scope class
  attach_function :al_get_bitmap_flags, :al_get_bitmap_flags, [:pointer], :int

  # (Not documented)
  #
  # @method al_create_bitmap(w, h)
  # @param [Integer] w
  # @param [Integer] h
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_create_bitmap, :al_create_bitmap, [:int, :int], :pointer

  # (Not documented)
  #
  # @method al_destroy_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [nil]
  # @scope class
  attach_function :al_destroy_bitmap, :al_destroy_bitmap, [:pointer], :void

  # (Not documented)
  #
  # @method al_put_pixel(x, y, color)
  # @param [Integer] x
  # @param [Integer] y
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_put_pixel, :al_put_pixel, [:int, :int, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_put_blended_pixel(x, y, color)
  # @param [Integer] x
  # @param [Integer] y
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_put_blended_pixel, :al_put_blended_pixel, [:int, :int, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_get_pixel(bitmap, x, y)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Integer] x
  # @param [Integer] y
  # @return [AllegroColor]
  # @scope class
  attach_function :al_get_pixel, :al_get_pixel, [:pointer, :int, :int], AllegroColor.by_value

  # (Not documented)
  #
  # @method al_convert_mask_to_alpha(bitmap, mask_color)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [AllegroColor] mask_color
  # @return [nil]
  # @scope class
  attach_function :al_convert_mask_to_alpha, :al_convert_mask_to_alpha, [:pointer, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_set_clipping_rectangle(x, y, width, height)
  # @param [Integer] x
  # @param [Integer] y
  # @param [Integer] width
  # @param [Integer] height
  # @return [nil]
  # @scope class
  attach_function :al_set_clipping_rectangle, :al_set_clipping_rectangle, [:int, :int, :int, :int], :void

  # (Not documented)
  #
  # @method al_reset_clipping_rectangle()
  # @return [nil]
  # @scope class
  attach_function :al_reset_clipping_rectangle, :al_reset_clipping_rectangle, [], :void

  # (Not documented)
  #
  # @method al_get_clipping_rectangle(x, y, w, h)
  # @param [FFI::Pointer(*Int)] x
  # @param [FFI::Pointer(*Int)] y
  # @param [FFI::Pointer(*Int)] w
  # @param [FFI::Pointer(*Int)] h
  # @return [nil]
  # @scope class
  attach_function :al_get_clipping_rectangle, :al_get_clipping_rectangle, [:pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_create_sub_bitmap(parent, x, y, w, h)
  # @param [FFI::Pointer(*AllegroBitmap)] parent
  # @param [Integer] x
  # @param [Integer] y
  # @param [Integer] w
  # @param [Integer] h
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_create_sub_bitmap, :al_create_sub_bitmap, [:pointer, :int, :int, :int, :int], :pointer

  # (Not documented)
  #
  # @method al_is_sub_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Boolean]
  # @scope class
  attach_function :al_is_sub_bitmap, :al_is_sub_bitmap, [:pointer], :bool

  # (Not documented)
  #
  # @method al_get_parent_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_get_parent_bitmap, :al_get_parent_bitmap, [:pointer], :pointer

  # (Not documented)
  #
  # @method al_clone_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_clone_bitmap, :al_clone_bitmap, [:pointer], :pointer

  # (Not documented)
  #
  # @method al_draw_bitmap(bitmap, dx, dy, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Float] dx
  # @param [Float] dy
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_bitmap, :al_draw_bitmap, [:pointer, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_bitmap_region(bitmap, sx, sy, sw, sh, dx, dy, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Float] sx
  # @param [Float] sy
  # @param [Float] sw
  # @param [Float] sh
  # @param [Float] dx
  # @param [Float] dy
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_bitmap_region, :al_draw_bitmap_region, [:pointer, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_scaled_bitmap(bitmap, sx, sy, sw, sh, dx, dy, dw, dh, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Float] sx
  # @param [Float] sy
  # @param [Float] sw
  # @param [Float] sh
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] dw
  # @param [Float] dh
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_scaled_bitmap, :al_draw_scaled_bitmap, [:pointer, :float, :float, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_rotated_bitmap(bitmap, cx, cy, dx, dy, angle, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] angle
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_rotated_bitmap, :al_draw_rotated_bitmap, [:pointer, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_scaled_rotated_bitmap(bitmap, cx, cy, dx, dy, xscale, yscale, angle, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] xscale
  # @param [Float] yscale
  # @param [Float] angle
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_scaled_rotated_bitmap, :al_draw_scaled_rotated_bitmap, [:pointer, :float, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_tinted_bitmap(bitmap, tint, dx, dy, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [AllegroColor] tint
  # @param [Float] dx
  # @param [Float] dy
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_tinted_bitmap, :al_draw_tinted_bitmap, [:pointer, AllegroColor.by_value, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_tinted_bitmap_region(bitmap, tint, sx, sy, sw, sh, dx, dy, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [AllegroColor] tint
  # @param [Float] sx
  # @param [Float] sy
  # @param [Float] sw
  # @param [Float] sh
  # @param [Float] dx
  # @param [Float] dy
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_tinted_bitmap_region, :al_draw_tinted_bitmap_region, [:pointer, AllegroColor.by_value, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_tinted_scaled_bitmap(bitmap, tint, sx, sy, sw, sh, dx, dy, dw, dh, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [AllegroColor] tint
  # @param [Float] sx
  # @param [Float] sy
  # @param [Float] sw
  # @param [Float] sh
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] dw
  # @param [Float] dh
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_tinted_scaled_bitmap, :al_draw_tinted_scaled_bitmap, [:pointer, AllegroColor.by_value, :float, :float, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_tinted_rotated_bitmap(bitmap, tint, cx, cy, dx, dy, angle, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [AllegroColor] tint
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] angle
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_tinted_rotated_bitmap, :al_draw_tinted_rotated_bitmap, [:pointer, AllegroColor.by_value, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_tinted_scaled_rotated_bitmap(bitmap, tint, cx, cy, dx, dy, xscale, yscale, angle, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [AllegroColor] tint
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] xscale
  # @param [Float] yscale
  # @param [Float] angle
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_tinted_scaled_rotated_bitmap, :al_draw_tinted_scaled_rotated_bitmap, [:pointer, AllegroColor.by_value, :float, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_tinted_scaled_rotated_bitmap_region(bitmap, sx, sy, sw, sh, tint, cx, cy, dx, dy, xscale, yscale, angle, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Float] sx
  # @param [Float] sy
  # @param [Float] sw
  # @param [Float] sh
  # @param [AllegroColor] tint
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] dx
  # @param [Float] dy
  # @param [Float] xscale
  # @param [Float] yscale
  # @param [Float] angle
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_draw_tinted_scaled_rotated_bitmap_region, :al_draw_tinted_scaled_rotated_bitmap_region, [:pointer, :float, :float, :float, :float, AllegroColor.by_value, :float, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  class AllegroPath < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # @method al_create_path(str)
  # @param [String] str
  # @return [AllegroPath]
  # @scope class
  attach_function :al_create_path, :al_create_path, [:string], AllegroPath

  # (Not documented)
  #
  # @method al_create_path_for_directory(str)
  # @param [String] str
  # @return [AllegroPath]
  # @scope class
  attach_function :al_create_path_for_directory, :al_create_path_for_directory, [:string], AllegroPath

  # (Not documented)
  #
  # @method al_clone_path(path)
  # @param [AllegroPath] path
  # @return [AllegroPath]
  # @scope class
  attach_function :al_clone_path, :al_clone_path, [AllegroPath], AllegroPath

  # (Not documented)
  #
  # @method al_get_path_num_components(path)
  # @param [AllegroPath] path
  # @return [Integer]
  # @scope class
  attach_function :al_get_path_num_components, :al_get_path_num_components, [AllegroPath], :int

  # (Not documented)
  #
  # @method al_get_path_component(path, i)
  # @param [AllegroPath] path
  # @param [Integer] i
  # @return [String]
  # @scope class
  attach_function :al_get_path_component, :al_get_path_component, [AllegroPath, :int], :string

  # (Not documented)
  #
  # @method al_replace_path_component(path, i, s)
  # @param [AllegroPath] path
  # @param [Integer] i
  # @param [String] s
  # @return [nil]
  # @scope class
  attach_function :al_replace_path_component, :al_replace_path_component, [AllegroPath, :int, :string], :void

  # (Not documented)
  #
  # @method al_remove_path_component(path, i)
  # @param [AllegroPath] path
  # @param [Integer] i
  # @return [nil]
  # @scope class
  attach_function :al_remove_path_component, :al_remove_path_component, [AllegroPath, :int], :void

  # (Not documented)
  #
  # @method al_insert_path_component(path, i, s)
  # @param [AllegroPath] path
  # @param [Integer] i
  # @param [String] s
  # @return [nil]
  # @scope class
  attach_function :al_insert_path_component, :al_insert_path_component, [AllegroPath, :int, :string], :void

  # (Not documented)
  #
  # @method al_get_path_tail(path)
  # @param [AllegroPath] path
  # @return [String]
  # @scope class
  attach_function :al_get_path_tail, :al_get_path_tail, [AllegroPath], :string

  # (Not documented)
  #
  # @method al_drop_path_tail(path)
  # @param [AllegroPath] path
  # @return [nil]
  # @scope class
  attach_function :al_drop_path_tail, :al_drop_path_tail, [AllegroPath], :void

  # (Not documented)
  #
  # @method al_append_path_component(path, s)
  # @param [AllegroPath] path
  # @param [String] s
  # @return [nil]
  # @scope class
  attach_function :al_append_path_component, :al_append_path_component, [AllegroPath, :string], :void

  # (Not documented)
  #
  # @method al_join_paths(path, tail)
  # @param [AllegroPath] path
  # @param [AllegroPath] tail
  # @return [Boolean]
  # @scope class
  attach_function :al_join_paths, :al_join_paths, [AllegroPath, AllegroPath], :bool

  # (Not documented)
  #
  # @method al_rebase_path(head, tail)
  # @param [AllegroPath] head
  # @param [AllegroPath] tail
  # @return [Boolean]
  # @scope class
  attach_function :al_rebase_path, :al_rebase_path, [AllegroPath, AllegroPath], :bool

  # (Not documented)
  #
  # @method al_path_cstr(path, delim)
  # @param [AllegroPath] path
  # @param [Integer] delim
  # @return [String]
  # @scope class
  attach_function :al_path_cstr, :al_path_cstr, [AllegroPath, :char], :string

  # (Not documented)
  #
  # @method al_destroy_path(path)
  # @param [AllegroPath] path
  # @return [nil]
  # @scope class
  attach_function :al_destroy_path, :al_destroy_path, [AllegroPath], :void

  # (Not documented)
  #
  # @method al_set_path_drive(path, drive)
  # @param [AllegroPath] path
  # @param [String] drive
  # @return [nil]
  # @scope class
  attach_function :al_set_path_drive, :al_set_path_drive, [AllegroPath, :string], :void

  # (Not documented)
  #
  # @method al_get_path_drive(path)
  # @param [AllegroPath] path
  # @return [String]
  # @scope class
  attach_function :al_get_path_drive, :al_get_path_drive, [AllegroPath], :string

  # (Not documented)
  #
  # @method al_set_path_filename(path, filename)
  # @param [AllegroPath] path
  # @param [String] filename
  # @return [nil]
  # @scope class
  attach_function :al_set_path_filename, :al_set_path_filename, [AllegroPath, :string], :void

  # (Not documented)
  #
  # @method al_get_path_filename(path)
  # @param [AllegroPath] path
  # @return [String]
  # @scope class
  attach_function :al_get_path_filename, :al_get_path_filename, [AllegroPath], :string

  # (Not documented)
  #
  # @method al_get_path_extension(path)
  # @param [AllegroPath] path
  # @return [String]
  # @scope class
  attach_function :al_get_path_extension, :al_get_path_extension, [AllegroPath], :string

  # (Not documented)
  #
  # @method al_set_path_extension(path, extension)
  # @param [AllegroPath] path
  # @param [String] extension
  # @return [Boolean]
  # @scope class
  attach_function :al_set_path_extension, :al_set_path_extension, [AllegroPath, :string], :bool

  # (Not documented)
  #
  # @method al_get_path_basename(path)
  # @param [AllegroPath] path
  # @return [String]
  # @scope class
  attach_function :al_get_path_basename, :al_get_path_basename, [AllegroPath], :string

  # (Not documented)
  #
  # @method al_make_path_canonical(path)
  # @param [AllegroPath] path
  # @return [Boolean]
  # @scope class
  attach_function :al_make_path_canonical, :al_make_path_canonical, [AllegroPath], :bool

  # (Not documented)
  #
  # = Fields:
  # :mlen ::
  #   (Integer)
  # :slen ::
  #   (Integer)
  # :data ::
  #   (FFI::Pointer(*Uchar))
  class AlTagbstring < FFI::Struct
    layout :mlen, :int,
           :slen, :int,
           :data, :pointer
  end

  # (Not documented)
  #
  # @method al_ustr_new(s)
  # @param [String] s
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_new, :al_ustr_new, [:string], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_new_from_buffer(s, size)
  # @param [String] s
  # @param [Integer] size
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_new_from_buffer, :al_ustr_new_from_buffer, [:string, :ulong], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_newf(fmt)
  # @param [String] fmt
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_newf, :al_ustr_newf, [:string], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_free(us)
  # @param [AlTagbstring] us
  # @return [nil]
  # @scope class
  attach_function :al_ustr_free, :al_ustr_free, [AlTagbstring], :void

  # (Not documented)
  #
  # @method al_cstr(us)
  # @param [AlTagbstring] us
  # @return [String]
  # @scope class
  attach_function :al_cstr, :al_cstr, [AlTagbstring], :string

  # (Not documented)
  #
  # @method al_ustr_to_buffer(us, buffer, size)
  # @param [AlTagbstring] us
  # @param [String] buffer
  # @param [Integer] size
  # @return [nil]
  # @scope class
  attach_function :al_ustr_to_buffer, :al_ustr_to_buffer, [AlTagbstring, :string, :int], :void

  # (Not documented)
  #
  # @method al_cstr_dup(us)
  # @param [AlTagbstring] us
  # @return [String]
  # @scope class
  attach_function :al_cstr_dup, :al_cstr_dup, [AlTagbstring], :string

  # (Not documented)
  #
  # @method al_ustr_dup(us)
  # @param [AlTagbstring] us
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_dup, :al_ustr_dup, [AlTagbstring], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_dup_substr(us, start_pos, end_pos)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [Integer] end_pos
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_dup_substr, :al_ustr_dup_substr, [AlTagbstring, :int, :int], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_empty_string()
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_empty_string, :al_ustr_empty_string, [], AlTagbstring

  # (Not documented)
  #
  # @method al_ref_cstr(info, s)
  # @param [AlTagbstring] info
  # @param [String] s
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ref_cstr, :al_ref_cstr, [AlTagbstring, :string], AlTagbstring

  # (Not documented)
  #
  # @method al_ref_buffer(info, s, size)
  # @param [AlTagbstring] info
  # @param [String] s
  # @param [Integer] size
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ref_buffer, :al_ref_buffer, [AlTagbstring, :string, :ulong], AlTagbstring

  # (Not documented)
  #
  # @method al_ref_ustr(info, us, start_pos, end_pos)
  # @param [AlTagbstring] info
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [Integer] end_pos
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ref_ustr, :al_ref_ustr, [AlTagbstring, AlTagbstring, :int, :int], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_size(us)
  # @param [AlTagbstring] us
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_size, :al_ustr_size, [AlTagbstring], :ulong

  # (Not documented)
  #
  # @method al_ustr_length(us)
  # @param [AlTagbstring] us
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_length, :al_ustr_length, [AlTagbstring], :ulong

  # (Not documented)
  #
  # @method al_ustr_offset(us, index)
  # @param [AlTagbstring] us
  # @param [Integer] index
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_offset, :al_ustr_offset, [AlTagbstring, :int], :int

  # (Not documented)
  #
  # @method al_ustr_next(us, pos)
  # @param [AlTagbstring] us
  # @param [FFI::Pointer(*Int)] pos
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_next, :al_ustr_next, [AlTagbstring, :pointer], :bool

  # (Not documented)
  #
  # @method al_ustr_prev(us, pos)
  # @param [AlTagbstring] us
  # @param [FFI::Pointer(*Int)] pos
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_prev, :al_ustr_prev, [AlTagbstring, :pointer], :bool

  # (Not documented)
  #
  # @method al_ustr_get(us, pos)
  # @param [AlTagbstring] us
  # @param [Integer] pos
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_get, :al_ustr_get, [AlTagbstring, :int], :int

  # (Not documented)
  #
  # @method al_ustr_get_next(us, pos)
  # @param [AlTagbstring] us
  # @param [FFI::Pointer(*Int)] pos
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_get_next, :al_ustr_get_next, [AlTagbstring, :pointer], :int

  # (Not documented)
  #
  # @method al_ustr_prev_get(us, pos)
  # @param [AlTagbstring] us
  # @param [FFI::Pointer(*Int)] pos
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_prev_get, :al_ustr_prev_get, [AlTagbstring, :pointer], :int

  # (Not documented)
  #
  # @method al_ustr_insert(us1, pos, us2)
  # @param [AlTagbstring] us1
  # @param [Integer] pos
  # @param [AlTagbstring] us2
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_insert, :al_ustr_insert, [AlTagbstring, :int, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_insert_cstr(us, pos, us2)
  # @param [AlTagbstring] us
  # @param [Integer] pos
  # @param [String] us2
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_insert_cstr, :al_ustr_insert_cstr, [AlTagbstring, :int, :string], :bool

  # (Not documented)
  #
  # @method al_ustr_insert_chr(us, pos, c)
  # @param [AlTagbstring] us
  # @param [Integer] pos
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_insert_chr, :al_ustr_insert_chr, [AlTagbstring, :int, :int], :ulong

  # (Not documented)
  #
  # @method al_ustr_append(us1, us2)
  # @param [AlTagbstring] us1
  # @param [AlTagbstring] us2
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_append, :al_ustr_append, [AlTagbstring, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_append_cstr(us, s)
  # @param [AlTagbstring] us
  # @param [String] s
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_append_cstr, :al_ustr_append_cstr, [AlTagbstring, :string], :bool

  # (Not documented)
  #
  # @method al_ustr_append_chr(us, c)
  # @param [AlTagbstring] us
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_append_chr, :al_ustr_append_chr, [AlTagbstring, :int], :ulong

  # (Not documented)
  #
  # @method al_ustr_appendf(us, fmt)
  # @param [AlTagbstring] us
  # @param [String] fmt
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_appendf, :al_ustr_appendf, [AlTagbstring, :string], :bool

  # (Not documented)
  #
  # @method al_ustr_vappendf(us, fmt, ap)
  # @param [AlTagbstring] us
  # @param [String] fmt
  # @param [Array<unknown>] ap
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_vappendf, :al_ustr_vappendf, [AlTagbstring, :string, :pointer], :bool

  # (Not documented)
  #
  # @method al_ustr_remove_chr(us, pos)
  # @param [AlTagbstring] us
  # @param [Integer] pos
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_remove_chr, :al_ustr_remove_chr, [AlTagbstring, :int], :bool

  # (Not documented)
  #
  # @method al_ustr_remove_range(us, start_pos, end_pos)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [Integer] end_pos
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_remove_range, :al_ustr_remove_range, [AlTagbstring, :int, :int], :bool

  # (Not documented)
  #
  # @method al_ustr_truncate(us, start_pos)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_truncate, :al_ustr_truncate, [AlTagbstring, :int], :bool

  # (Not documented)
  #
  # @method al_ustr_ltrim_ws(us)
  # @param [AlTagbstring] us
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_ltrim_ws, :al_ustr_ltrim_ws, [AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_rtrim_ws(us)
  # @param [AlTagbstring] us
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_rtrim_ws, :al_ustr_rtrim_ws, [AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_trim_ws(us)
  # @param [AlTagbstring] us
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_trim_ws, :al_ustr_trim_ws, [AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_assign(us1, us2)
  # @param [AlTagbstring] us1
  # @param [AlTagbstring] us2
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_assign, :al_ustr_assign, [AlTagbstring, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_assign_substr(us1, us2, start_pos, end_pos)
  # @param [AlTagbstring] us1
  # @param [AlTagbstring] us2
  # @param [Integer] start_pos
  # @param [Integer] end_pos
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_assign_substr, :al_ustr_assign_substr, [AlTagbstring, AlTagbstring, :int, :int], :bool

  # (Not documented)
  #
  # @method al_ustr_assign_cstr(us1, s)
  # @param [AlTagbstring] us1
  # @param [String] s
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_assign_cstr, :al_ustr_assign_cstr, [AlTagbstring, :string], :bool

  # (Not documented)
  #
  # @method al_ustr_set_chr(us, pos, c)
  # @param [AlTagbstring] us
  # @param [Integer] pos
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_set_chr, :al_ustr_set_chr, [AlTagbstring, :int, :int], :ulong

  # (Not documented)
  #
  # @method al_ustr_replace_range(us1, start_pos1, end_pos1, us2)
  # @param [AlTagbstring] us1
  # @param [Integer] start_pos1
  # @param [Integer] end_pos1
  # @param [AlTagbstring] us2
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_replace_range, :al_ustr_replace_range, [AlTagbstring, :int, :int, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_find_chr(us, start_pos, c)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_chr, :al_ustr_find_chr, [AlTagbstring, :int, :int], :int

  # (Not documented)
  #
  # @method al_ustr_rfind_chr(us, start_pos, c)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_rfind_chr, :al_ustr_rfind_chr, [AlTagbstring, :int, :int], :int

  # (Not documented)
  #
  # @method al_ustr_find_set(us, start_pos, accept)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [AlTagbstring] accept
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_set, :al_ustr_find_set, [AlTagbstring, :int, AlTagbstring], :int

  # (Not documented)
  #
  # @method al_ustr_find_set_cstr(us, start_pos, accept)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [String] accept
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_set_cstr, :al_ustr_find_set_cstr, [AlTagbstring, :int, :string], :int

  # (Not documented)
  #
  # @method al_ustr_find_cset(us, start_pos, reject)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [AlTagbstring] reject
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_cset, :al_ustr_find_cset, [AlTagbstring, :int, AlTagbstring], :int

  # (Not documented)
  #
  # @method al_ustr_find_cset_cstr(us, start_pos, reject)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [String] reject
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_cset_cstr, :al_ustr_find_cset_cstr, [AlTagbstring, :int, :string], :int

  # (Not documented)
  #
  # @method al_ustr_find_str(haystack, start_pos, needle)
  # @param [AlTagbstring] haystack
  # @param [Integer] start_pos
  # @param [AlTagbstring] needle
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_str, :al_ustr_find_str, [AlTagbstring, :int, AlTagbstring], :int

  # (Not documented)
  #
  # @method al_ustr_find_cstr(haystack, start_pos, needle)
  # @param [AlTagbstring] haystack
  # @param [Integer] start_pos
  # @param [String] needle
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_find_cstr, :al_ustr_find_cstr, [AlTagbstring, :int, :string], :int

  # (Not documented)
  #
  # @method al_ustr_rfind_str(haystack, start_pos, needle)
  # @param [AlTagbstring] haystack
  # @param [Integer] start_pos
  # @param [AlTagbstring] needle
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_rfind_str, :al_ustr_rfind_str, [AlTagbstring, :int, AlTagbstring], :int

  # (Not documented)
  #
  # @method al_ustr_rfind_cstr(haystack, start_pos, needle)
  # @param [AlTagbstring] haystack
  # @param [Integer] start_pos
  # @param [String] needle
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_rfind_cstr, :al_ustr_rfind_cstr, [AlTagbstring, :int, :string], :int

  # (Not documented)
  #
  # @method al_ustr_find_replace(us, start_pos, find, replace)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [AlTagbstring] find
  # @param [AlTagbstring] replace
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_find_replace, :al_ustr_find_replace, [AlTagbstring, :int, AlTagbstring, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_find_replace_cstr(us, start_pos, find, replace)
  # @param [AlTagbstring] us
  # @param [Integer] start_pos
  # @param [String] find
  # @param [String] replace
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_find_replace_cstr, :al_ustr_find_replace_cstr, [AlTagbstring, :int, :string, :string], :bool

  # (Not documented)
  #
  # @method al_ustr_equal(us1, us2)
  # @param [AlTagbstring] us1
  # @param [AlTagbstring] us2
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_equal, :al_ustr_equal, [AlTagbstring, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_compare(u, v)
  # @param [AlTagbstring] u
  # @param [AlTagbstring] v
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_compare, :al_ustr_compare, [AlTagbstring, AlTagbstring], :int

  # (Not documented)
  #
  # @method al_ustr_ncompare(us1, us2, n)
  # @param [AlTagbstring] us1
  # @param [AlTagbstring] us2
  # @param [Integer] n
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_ncompare, :al_ustr_ncompare, [AlTagbstring, AlTagbstring, :int], :int

  # (Not documented)
  #
  # @method al_ustr_has_prefix(u, v)
  # @param [AlTagbstring] u
  # @param [AlTagbstring] v
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_has_prefix, :al_ustr_has_prefix, [AlTagbstring, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_has_prefix_cstr(u, s)
  # @param [AlTagbstring] u
  # @param [String] s
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_has_prefix_cstr, :al_ustr_has_prefix_cstr, [AlTagbstring, :string], :bool

  # (Not documented)
  #
  # @method al_ustr_has_suffix(u, v)
  # @param [AlTagbstring] u
  # @param [AlTagbstring] v
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_has_suffix, :al_ustr_has_suffix, [AlTagbstring, AlTagbstring], :bool

  # (Not documented)
  #
  # @method al_ustr_has_suffix_cstr(us1, s)
  # @param [AlTagbstring] us1
  # @param [String] s
  # @return [Boolean]
  # @scope class
  attach_function :al_ustr_has_suffix_cstr, :al_ustr_has_suffix_cstr, [AlTagbstring, :string], :bool

  # (Not documented)
  #
  # @method al_utf8_width(c)
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_utf8_width, :al_utf8_width, [:int], :ulong

  # (Not documented)
  #
  # @method al_utf8_encode(s, c)
  # @param [FFI::Pointer(*Char_s)] s
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_utf8_encode, :al_utf8_encode, [:pointer, :int], :ulong

  # (Not documented)
  #
  # @method al_ustr_new_from_utf16(s)
  # @param [FFI::Pointer(*Uint16T)] s
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_ustr_new_from_utf16, :al_ustr_new_from_utf16, [:pointer], AlTagbstring

  # (Not documented)
  #
  # @method al_ustr_size_utf16(us)
  # @param [AlTagbstring] us
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_size_utf16, :al_ustr_size_utf16, [AlTagbstring], :ulong

  # (Not documented)
  #
  # @method al_ustr_encode_utf16(us, s, n)
  # @param [AlTagbstring] us
  # @param [FFI::Pointer(*Uint16T)] s
  # @param [Integer] n
  # @return [Integer]
  # @scope class
  attach_function :al_ustr_encode_utf16, :al_ustr_encode_utf16, [AlTagbstring, :pointer, :ulong], :ulong

  # (Not documented)
  #
  # @method al_utf16_width(c)
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_utf16_width, :al_utf16_width, [:int], :ulong

  # (Not documented)
  #
  # @method al_utf16_encode(s, c)
  # @param [FFI::Pointer(*U_short)] s
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_utf16_encode, :al_utf16_encode, [:pointer, :int], :ulong

  # (Not documented)
  class AllegroFile < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # = Fields:
  # :fi_fopen ::
  #   (FFI::Pointer(*))
  # :fi_fclose ::
  #   (FFI::Pointer(*))
  # :fi_fread ::
  #   (FFI::Pointer(*))
  # :fi_fwrite ::
  #   (FFI::Pointer(*))
  # :fi_fflush ::
  #   (FFI::Pointer(*))
  # :fi_ftell ::
  #   (FFI::Pointer(*))
  # :fi_fseek ::
  #   (FFI::Pointer(*))
  # :fi_feof ::
  #   (FFI::Pointer(*))
  # :fi_ferror ::
  #   (FFI::Pointer(*))
  # :fi_fclearerr ::
  #   (FFI::Pointer(*))
  # :fi_fungetc ::
  #   (FFI::Pointer(*))
  # :fi_fsize ::
  #   (FFI::Pointer(*))
  class AllegroFileInterface < FFI::Struct
    layout :fi_fopen, :pointer,
           :fi_fclose, :pointer,
           :fi_fread, :pointer,
           :fi_fwrite, :pointer,
           :fi_fflush, :pointer,
           :fi_ftell, :pointer,
           :fi_fseek, :pointer,
           :fi_feof, :pointer,
           :fi_ferror, :pointer,
           :fi_fclearerr, :pointer,
           :fi_fungetc, :pointer,
           :fi_fsize, :pointer
  end

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_seek).</em>
  #
  # === Options:
  # :allegro_seek_set ::
  #
  # :allegro_seek_cur ::
  #
  # :allegro_seek_end ::
  #
  #
  # @method _enum_allegro_seek_
  # @return [Symbol]
  # @scope class
  enum :allegro_seek, [
    :allegro_seek_set, 0,
    :allegro_seek_cur, 1,
    :allegro_seek_end, 2
  ]

  # (Not documented)
  #
  # @method al_fopen(path, mode)
  # @param [String] path
  # @param [String] mode
  # @return [AllegroFile]
  # @scope class
  attach_function :al_fopen, :al_fopen, [:string, :string], AllegroFile

  # (Not documented)
  #
  # @method al_fopen_interface(vt, path, mode)
  # @param [AllegroFileInterface] vt
  # @param [String] path
  # @param [String] mode
  # @return [AllegroFile]
  # @scope class
  attach_function :al_fopen_interface, :al_fopen_interface, [AllegroFileInterface, :string, :string], AllegroFile

  # (Not documented)
  #
  # @method al_create_file_handle(vt, userdata)
  # @param [AllegroFileInterface] vt
  # @param [FFI::Pointer(*Void)] userdata
  # @return [AllegroFile]
  # @scope class
  attach_function :al_create_file_handle, :al_create_file_handle, [AllegroFileInterface, :pointer], AllegroFile

  # (Not documented)
  #
  # @method al_fclose(f)
  # @param [AllegroFile] f
  # @return [nil]
  # @scope class
  attach_function :al_fclose, :al_fclose, [AllegroFile], :void

  # (Not documented)
  #
  # @method al_fread(f, ptr, size)
  # @param [AllegroFile] f
  # @param [FFI::Pointer(*Void)] ptr
  # @param [Integer] size
  # @return [Integer]
  # @scope class
  attach_function :al_fread, :al_fread, [AllegroFile, :pointer, :ulong], :ulong

  # (Not documented)
  #
  # @method al_fwrite(f, ptr, size)
  # @param [AllegroFile] f
  # @param [FFI::Pointer(*Void)] ptr
  # @param [Integer] size
  # @return [Integer]
  # @scope class
  attach_function :al_fwrite, :al_fwrite, [AllegroFile, :pointer, :ulong], :ulong

  # (Not documented)
  #
  # @method al_fflush(f)
  # @param [AllegroFile] f
  # @return [Boolean]
  # @scope class
  attach_function :al_fflush, :al_fflush, [AllegroFile], :bool

  # (Not documented)
  #
  # @method al_ftell(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_ftell, :al_ftell, [AllegroFile], :long_long

  # (Not documented)
  #
  # @method al_fseek(f, offset, whence)
  # @param [AllegroFile] f
  # @param [Integer] offset
  # @param [Integer] whence
  # @return [Boolean]
  # @scope class
  attach_function :al_fseek, :al_fseek, [AllegroFile, :long_long, :int], :bool

  # (Not documented)
  #
  # @method al_feof(f)
  # @param [AllegroFile] f
  # @return [Boolean]
  # @scope class
  attach_function :al_feof, :al_feof, [AllegroFile], :bool

  # (Not documented)
  #
  # @method al_ferror(f)
  # @param [AllegroFile] f
  # @return [Boolean]
  # @scope class
  attach_function :al_ferror, :al_ferror, [AllegroFile], :bool

  # (Not documented)
  #
  # @method al_fclearerr(f)
  # @param [AllegroFile] f
  # @return [nil]
  # @scope class
  attach_function :al_fclearerr, :al_fclearerr, [AllegroFile], :void

  # (Not documented)
  #
  # @method al_fungetc(f, c)
  # @param [AllegroFile] f
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_fungetc, :al_fungetc, [AllegroFile, :int], :int

  # (Not documented)
  #
  # @method al_fsize(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_fsize, :al_fsize, [AllegroFile], :long_long

  # (Not documented)
  #
  # @method al_fgetc(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_fgetc, :al_fgetc, [AllegroFile], :int

  # (Not documented)
  #
  # @method al_fputc(f, c)
  # @param [AllegroFile] f
  # @param [Integer] c
  # @return [Integer]
  # @scope class
  attach_function :al_fputc, :al_fputc, [AllegroFile, :int], :int

  # (Not documented)
  #
  # @method al_fread16le(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_fread16le, :al_fread16le, [AllegroFile], :short

  # (Not documented)
  #
  # @method al_fread16be(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_fread16be, :al_fread16be, [AllegroFile], :short

  # (Not documented)
  #
  # @method al_fwrite16le(f, w)
  # @param [AllegroFile] f
  # @param [Integer] w
  # @return [Integer]
  # @scope class
  attach_function :al_fwrite16le, :al_fwrite16le, [AllegroFile, :short], :ulong

  # (Not documented)
  #
  # @method al_fwrite16be(f, w)
  # @param [AllegroFile] f
  # @param [Integer] w
  # @return [Integer]
  # @scope class
  attach_function :al_fwrite16be, :al_fwrite16be, [AllegroFile, :short], :ulong

  # (Not documented)
  #
  # @method al_fread32le(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_fread32le, :al_fread32le, [AllegroFile], :int

  # (Not documented)
  #
  # @method al_fread32be(f)
  # @param [AllegroFile] f
  # @return [Integer]
  # @scope class
  attach_function :al_fread32be, :al_fread32be, [AllegroFile], :int

  # (Not documented)
  #
  # @method al_fwrite32le(f, l)
  # @param [AllegroFile] f
  # @param [Integer] l
  # @return [Integer]
  # @scope class
  attach_function :al_fwrite32le, :al_fwrite32le, [AllegroFile, :int], :ulong

  # (Not documented)
  #
  # @method al_fwrite32be(f, l)
  # @param [AllegroFile] f
  # @param [Integer] l
  # @return [Integer]
  # @scope class
  attach_function :al_fwrite32be, :al_fwrite32be, [AllegroFile, :int], :ulong

  # (Not documented)
  #
  # @method al_fgets(f, p, max)
  # @param [AllegroFile] f
  # @param [String] p
  # @param [Integer] max
  # @return [String]
  # @scope class
  attach_function :al_fgets, :al_fgets, [AllegroFile, :string, :ulong], :string

  # (Not documented)
  #
  # @method al_fget_ustr(f)
  # @param [AllegroFile] f
  # @return [AlTagbstring]
  # @scope class
  attach_function :al_fget_ustr, :al_fget_ustr, [AllegroFile], AlTagbstring

  # (Not documented)
  #
  # @method al_fputs(f, p)
  # @param [AllegroFile] f
  # @param [String] p
  # @return [Integer]
  # @scope class
  attach_function :al_fputs, :al_fputs, [AllegroFile, :string], :int

  # (Not documented)
  #
  # @method al_fopen_fd(fd, mode)
  # @param [Integer] fd
  # @param [String] mode
  # @return [AllegroFile]
  # @scope class
  attach_function :al_fopen_fd, :al_fopen_fd, [:int, :string], AllegroFile

  # (Not documented)
  #
  # @method al_make_temp_file(tmpl, ret_path)
  # @param [String] tmpl
  # @param [FFI::Pointer(**AllegroPath)] ret_path
  # @return [AllegroFile]
  # @scope class
  attach_function :al_make_temp_file, :al_make_temp_file, [:string, :pointer], AllegroFile

  # (Not documented)
  #
  # @method al_fopen_slice(fp, initial_size, mode)
  # @param [AllegroFile] fp
  # @param [Integer] initial_size
  # @param [String] mode
  # @return [AllegroFile]
  # @scope class
  attach_function :al_fopen_slice, :al_fopen_slice, [AllegroFile, :ulong, :string], AllegroFile

  # (Not documented)
  #
  # @method al_get_new_file_interface()
  # @return [AllegroFileInterface]
  # @scope class
  attach_function :al_get_new_file_interface, :al_get_new_file_interface, [], AllegroFileInterface

  # (Not documented)
  #
  # @method al_set_new_file_interface(file_interface)
  # @param [AllegroFileInterface] file_interface
  # @return [nil]
  # @scope class
  attach_function :al_set_new_file_interface, :al_set_new_file_interface, [AllegroFileInterface], :void

  # (Not documented)
  #
  # @method al_set_standard_file_interface()
  # @return [nil]
  # @scope class
  attach_function :al_set_standard_file_interface, :al_set_standard_file_interface, [], :void

  # (Not documented)
  #
  # @method al_get_file_userdata(f)
  # @param [AllegroFile] f
  # @return [FFI::Pointer(*Void)]
  # @scope class
  attach_function :al_get_file_userdata, :al_get_file_userdata, [AllegroFile], :pointer

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method.</em>
  #
  # @method _callback_allegro_iio_loader_function_(allegro_bitmap, filename)
  # @param [AllegroBitmap] allegro_bitmap
  # @param [String] filename
  # @return [AllegroBitmap]
  # @scope class
  callback :allegro_iio_loader_function, [:pointer, :string], :pointer

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method.</em>
  #
  # @method _callback_allegro_iio_fs_loader_function_(allegro_bitmap, fp)
  # @param [AllegroBitmap] allegro_bitmap
  # @param [AllegroFile] fp
  # @return [AllegroBitmap]
  # @scope class
  callback :allegro_iio_fs_loader_function, [:pointer, AllegroFile], :pointer

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method.</em>
  #
  # @method _callback_allegro_iio_saver_function_(filename, bitmap)
  # @param [String] filename
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [String]
  # @scope class
  callback :allegro_iio_saver_function, [:string, :pointer], :string

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method.</em>
  #
  # @method _callback_allegro_iio_fs_saver_function_(fp, bitmap)
  # @param [AllegroFile] fp
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [AllegroFile]
  # @scope class
  callback :allegro_iio_fs_saver_function, [AllegroFile, :pointer], AllegroFile

  # (Not documented)
  #
  # @method al_register_bitmap_loader(ext, loader)
  # @param [String] ext
  # @param [Proc(_callback_allegro_iio_loader_function_)] loader
  # @return [Boolean]
  # @scope class
  attach_function :al_register_bitmap_loader, :al_register_bitmap_loader, [:string, :allegro_iio_loader_function], :bool

  # (Not documented)
  #
  # @method al_register_bitmap_saver(ext, saver)
  # @param [String] ext
  # @param [Proc(_callback_allegro_iio_saver_function_)] saver
  # @return [Boolean]
  # @scope class
  attach_function :al_register_bitmap_saver, :al_register_bitmap_saver, [:string, :allegro_iio_saver_function], :bool

  # (Not documented)
  #
  # @method al_register_bitmap_loader_f(ext, fs_loader)
  # @param [String] ext
  # @param [Proc(_callback_allegro_iio_fs_loader_function_)] fs_loader
  # @return [Boolean]
  # @scope class
  attach_function :al_register_bitmap_loader_f, :al_register_bitmap_loader_f, [:string, :allegro_iio_fs_loader_function], :bool

  # (Not documented)
  #
  # @method al_register_bitmap_saver_f(ext, fs_saver)
  # @param [String] ext
  # @param [Proc(_callback_allegro_iio_fs_saver_function_)] fs_saver
  # @return [Boolean]
  # @scope class
  attach_function :al_register_bitmap_saver_f, :al_register_bitmap_saver_f, [:string, :allegro_iio_fs_saver_function], :bool

  # (Not documented)
  #
  # @method al_load_bitmap(filename)
  # @param [String] filename
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_load_bitmap, :al_load_bitmap, [:string], :pointer

  # (Not documented)
  #
  # @method al_load_bitmap_f(fp, ident)
  # @param [AllegroFile] fp
  # @param [String] ident
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_load_bitmap_f, :al_load_bitmap_f, [AllegroFile, :string], :pointer

  # (Not documented)
  #
  # @method al_save_bitmap(filename, bitmap)
  # @param [String] filename
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Boolean]
  # @scope class
  attach_function :al_save_bitmap, :al_save_bitmap, [:string, :pointer], :bool

  # (Not documented)
  #
  # @method al_save_bitmap_f(fp, ident, bitmap)
  # @param [AllegroFile] fp
  # @param [String] ident
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Boolean]
  # @scope class
  attach_function :al_save_bitmap_f, :al_save_bitmap_f, [AllegroFile, :string, :pointer], :bool

  # (Not documented)
  #
  # = Fields:
  # :data ::
  #   (FFI::Pointer(*Void))
  # :format ::
  #   (Integer)
  # :pitch ::
  #   (Integer)
  # :pixel_size ::
  #   (Integer)
  class AllegroLockedRegion < FFI::Struct
    layout :data, :pointer,
           :format, :int,
           :pitch, :int,
           :pixel_size, :int
  end

  # (Not documented)
  #
  # @method al_lock_bitmap(bitmap, format, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Integer] format
  # @param [Integer] flags
  # @return [AllegroLockedRegion]
  # @scope class
  attach_function :al_lock_bitmap, :al_lock_bitmap, [:pointer, :int, :int], AllegroLockedRegion.by_ref

  # (Not documented)
  #
  # @method al_lock_bitmap_region(bitmap, x, y, width, height, format, flags)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @param [Integer] x
  # @param [Integer] y
  # @param [Integer] width
  # @param [Integer] height
  # @param [Integer] format
  # @param [Integer] flags
  # @return [AllegroLockedRegion]
  # @scope class
  attach_function :al_lock_bitmap_region, :al_lock_bitmap_region, [:pointer, :int, :int, :int, :int, :int, :int], AllegroLockedRegion.by_ref

  # (Not documented)
  #
  # @method al_unlock_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [nil]
  # @scope class
  attach_function :al_unlock_bitmap, :al_unlock_bitmap, [:pointer], :void

  # (Not documented)
  #
  # @method al_is_bitmap_locked(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Boolean]
  # @scope class
  attach_function :al_is_bitmap_locked, :al_is_bitmap_locked, [:pointer], :bool

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_blend_mode).</em>
  #
  # === Options:
  # :allegro_zero ::
  #
  # :allegro_one ::
  #
  # :allegro_alpha ::
  #
  # :allegro_inverse_alpha ::
  #
  # :allegro_src_color ::
  #
  # :allegro_dest_color ::
  #
  # :allegro_inverse_src_color ::
  #
  # :allegro_inverse_dest_color ::
  #
  # :allegro_num_blend_modes ::
  #
  #
  # @method _enum_allegro_blend_mode_
  # @return [Symbol]
  # @scope class
  enum :allegro_blend_mode, [
    :allegro_zero, 0,
    :allegro_one, 1,
    :allegro_alpha, 2,
    :allegro_inverse_alpha, 3,
    :allegro_src_color, 4,
    :allegro_dest_color, 5,
    :allegro_inverse_src_color, 6,
    :allegro_inverse_dest_color, 7,
    :allegro_num_blend_modes, 8
  ]

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_blend_operations).</em>
  #
  # === Options:
  # :allegro_add ::
  #
  # :allegro_src_minus_dest ::
  #
  # :allegro_dest_minus_src ::
  #
  # :allegro_num_blend_operations ::
  #
  #
  # @method _enum_allegro_blend_operations_
  # @return [Symbol]
  # @scope class
  enum :allegro_blend_operations, [
    :allegro_add, 0,
    :allegro_src_minus_dest, 1,
    :allegro_dest_minus_src, 2,
    :allegro_num_blend_operations, 3
  ]

  # (Not documented)
  #
  # @method al_set_blender(op, source, dest)
  # @param [Integer] op
  # @param [Integer] source
  # @param [Integer] dest
  # @return [nil]
  # @scope class
  attach_function :al_set_blender, :al_set_blender, [:int, :int, :int], :void

  # (Not documented)
  #
  # @method al_get_blender(op, source, dest)
  # @param [FFI::Pointer(*Int)] op
  # @param [FFI::Pointer(*Int)] source
  # @param [FFI::Pointer(*Int)] dest
  # @return [nil]
  # @scope class
  attach_function :al_get_blender, :al_get_blender, [:pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_set_separate_blender(op, source, dest, alpha_op, alpha_source, alpha_dest)
  # @param [Integer] op
  # @param [Integer] source
  # @param [Integer] dest
  # @param [Integer] alpha_op
  # @param [Integer] alpha_source
  # @param [Integer] alpha_dest
  # @return [nil]
  # @scope class
  attach_function :al_set_separate_blender, :al_set_separate_blender, [:int, :int, :int, :int, :int, :int], :void

  # (Not documented)
  #
  # @method al_get_separate_blender(op, source, dest, alpha_op, alpha_src, alpha_dest)
  # @param [FFI::Pointer(*Int)] op
  # @param [FFI::Pointer(*Int)] source
  # @param [FFI::Pointer(*Int)] dest
  # @param [FFI::Pointer(*Int)] alpha_op
  # @param [FFI::Pointer(*Int)] alpha_src
  # @param [FFI::Pointer(*Int)] alpha_dest
  # @return [nil]
  # @scope class
  attach_function :al_get_separate_blender, :al_get_separate_blender, [:pointer, :pointer, :pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  class AllegroConfig < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  class AllegroConfigSection < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  class AllegroConfigEntry < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # @method al_create_config()
  # @return [AllegroConfig]
  # @scope class
  attach_function :al_create_config, :al_create_config, [], AllegroConfig

  # (Not documented)
  #
  # @method al_add_config_section(config, name)
  # @param [AllegroConfig] config
  # @param [String] name
  # @return [nil]
  # @scope class
  attach_function :al_add_config_section, :al_add_config_section, [AllegroConfig, :string], :void

  # (Not documented)
  #
  # @method al_set_config_value(config, section, key, value)
  # @param [AllegroConfig] config
  # @param [String] section
  # @param [String] key
  # @param [String] value
  # @return [nil]
  # @scope class
  attach_function :al_set_config_value, :al_set_config_value, [AllegroConfig, :string, :string, :string], :void

  # (Not documented)
  #
  # @method al_add_config_comment(config, section, comment)
  # @param [AllegroConfig] config
  # @param [String] section
  # @param [String] comment
  # @return [nil]
  # @scope class
  attach_function :al_add_config_comment, :al_add_config_comment, [AllegroConfig, :string, :string], :void

  # (Not documented)
  #
  # @method al_get_config_value(config, section, key)
  # @param [AllegroConfig] config
  # @param [String] section
  # @param [String] key
  # @return [String]
  # @scope class
  attach_function :al_get_config_value, :al_get_config_value, [AllegroConfig, :string, :string], :string

  # (Not documented)
  #
  # @method al_load_config_file(filename)
  # @param [String] filename
  # @return [AllegroConfig]
  # @scope class
  attach_function :al_load_config_file, :al_load_config_file, [:string], AllegroConfig

  # (Not documented)
  #
  # @method al_load_config_file_f(filename)
  # @param [AllegroFile] filename
  # @return [AllegroConfig]
  # @scope class
  attach_function :al_load_config_file_f, :al_load_config_file_f, [AllegroFile], AllegroConfig

  # (Not documented)
  #
  # @method al_save_config_file(filename, config)
  # @param [String] filename
  # @param [AllegroConfig] config
  # @return [Boolean]
  # @scope class
  attach_function :al_save_config_file, :al_save_config_file, [:string, AllegroConfig], :bool

  # (Not documented)
  #
  # @method al_save_config_file_f(file, config)
  # @param [AllegroFile] file
  # @param [AllegroConfig] config
  # @return [Boolean]
  # @scope class
  attach_function :al_save_config_file_f, :al_save_config_file_f, [AllegroFile, AllegroConfig], :bool

  # (Not documented)
  #
  # @method al_merge_config_into(master, add)
  # @param [AllegroConfig] master
  # @param [AllegroConfig] add
  # @return [nil]
  # @scope class
  attach_function :al_merge_config_into, :al_merge_config_into, [AllegroConfig, AllegroConfig], :void

  # (Not documented)
  #
  # @method al_merge_config(cfg1, cfg2)
  # @param [AllegroConfig] cfg1
  # @param [AllegroConfig] cfg2
  # @return [AllegroConfig]
  # @scope class
  attach_function :al_merge_config, :al_merge_config, [AllegroConfig, AllegroConfig], AllegroConfig

  # (Not documented)
  #
  # @method al_destroy_config(config)
  # @param [AllegroConfig] config
  # @return [nil]
  # @scope class
  attach_function :al_destroy_config, :al_destroy_config, [AllegroConfig], :void

  # (Not documented)
  #
  # @method al_get_first_config_section(config, iterator)
  # @param [AllegroConfig] config
  # @param [FFI::Pointer(**AllegroConfigSection)] iterator
  # @return [String]
  # @scope class
  attach_function :al_get_first_config_section, :al_get_first_config_section, [AllegroConfig, :pointer], :string

  # (Not documented)
  #
  # @method al_get_next_config_section(iterator)
  # @param [FFI::Pointer(**AllegroConfigSection)] iterator
  # @return [String]
  # @scope class
  attach_function :al_get_next_config_section, :al_get_next_config_section, [:pointer], :string

  # (Not documented)
  #
  # @method al_get_first_config_entry(config, section, iterator)
  # @param [AllegroConfig] config
  # @param [String] section
  # @param [FFI::Pointer(**AllegroConfigEntry)] iterator
  # @return [String]
  # @scope class
  attach_function :al_get_first_config_entry, :al_get_first_config_entry, [AllegroConfig, :string, :pointer], :string

  # (Not documented)
  #
  # @method al_get_next_config_entry(iterator)
  # @param [FFI::Pointer(**AllegroConfigEntry)] iterator
  # @return [String]
  # @scope class
  attach_function :al_get_next_config_entry, :al_get_next_config_entry, [:pointer], :string

  # (Not documented)
  #
  # @method al_trace_prefix(channel, level, file, line, function)
  # @param [String] channel
  # @param [Integer] level
  # @param [String] file
  # @param [Integer] line
  # @param [String] function
  # @return [Boolean]
  # @scope class
  attach_function :al_trace_prefix, :_al_trace_prefix, [:string, :int, :string, :int, :string], :bool

  # (Not documented)
  #
  # @method al_trace_suffix(msg)
  # @param [String] msg
  # @return [nil]
  # @scope class
  attach_function :al_trace_suffix, :_al_trace_suffix, [:string], :void

  # (Not documented)
  #
  # @method al_register_assert_handler(handler)
  # @param [FFI::Pointer(*)] handler
  # @return [nil]
  # @scope class
  attach_function :al_register_assert_handler, :al_register_assert_handler, [:pointer], :void

  # (Not documented)
  #
  # = Fields:
  # :pad ::
  #   (Array<Integer>)
  class AllegroEventSource < FFI::Struct
    layout :pad, [:int, 32]
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (AllegroEventSource)
  # :timestamp ::
  #   (Float)
  class AllegroAnyEvent < FFI::Struct
    layout :type, :uint,
           :source, AllegroEventSource.by_ref,
           :timestamp, :double
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (FFI::Pointer(*AllegroDisplay))
  # :timestamp ::
  #   (Float)
  # :x ::
  #   (Integer)
  # :y ::
  #   (Integer)
  # :width ::
  #   (Integer)
  # :height ::
  #   (Integer)
  # :orientation ::
  #   (Integer)
  class AllegroDisplayEvent < FFI::Struct
    layout :type, :uint,
           :source, :pointer,
           :timestamp, :double,
           :x, :int,
           :y, :int,
           :width, :int,
           :height, :int,
           :orientation, :int
  end

  # (Not documented)
  class AllegroJoystick < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (AllegroJoystick)
  # :timestamp ::
  #   (Float)
  # :id ::
  #   (AllegroJoystick)
  # :stick ::
  #   (Integer)
  # :axis ::
  #   (Integer)
  # :pos ::
  #   (Float)
  # :button ::
  #   (Integer)
  class AllegroJoystickEvent < FFI::Struct
    layout :type, :uint,
           :source, AllegroJoystick.by_ref,
           :timestamp, :double,
           :id, AllegroJoystick.by_ref,
           :stick, :int,
           :axis, :int,
           :pos, :float,
           :button, :int
  end

  # (Not documented)
  class AllegroKeyboard < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (AllegroKeyboard)
  # :timestamp ::
  #   (Float)
  # :display ::
  #   (FFI::Pointer(*AllegroDisplay)) the window the key was pressed in
  # :keycode ::
  #   (Integer) the physical key pressed
  # :unichar ::
  #   (Integer) unicode character or negative
  # :modifiers ::
  #   (Integer) bitfield
  # :repeat ::
  #   (Boolean) auto-repeated or not
  class AllegroKeyboardEvent < FFI::Struct
    layout :type, :uint,
           :source, AllegroKeyboard.by_ref,
           :timestamp, :double,
           :display, :pointer,
           :keycode, :int,
           :unichar, :int,
           :modifiers, :uint,
           :repeat, :bool
  end

  # (Not documented)
  class AllegroMouse < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (AllegroMouse)
  # :timestamp ::
  #   (Float)
  # :display ::
  #   (FFI::Pointer(*AllegroDisplay))
  # :x ::
  #   (Integer) (display) Window the event originate from
  #   (x, y) Primary mouse position
  #   (z) Mouse wheel position (1D 'wheel'), or,
  #   (w, z) Mouse wheel position (2D 'ball')
  #   (pressure) The pressure applied, for stylus (0 or 1 for normal mouse)
  # :y ::
  #   (Integer)
  # :z ::
  #   (Integer)
  # :w ::
  #   (Integer)
  # :dx ::
  #   (Integer)
  # :dy ::
  #   (Integer)
  # :dz ::
  #   (Integer)
  # :dw ::
  #   (Integer)
  # :button ::
  #   (Integer)
  # :pressure ::
  #   (Float)
  class AllegroMouseEvent < FFI::Struct
    layout :type, :uint,
           :source, AllegroMouse.by_ref,
           :timestamp, :double,
           :display, :pointer,
           :x, :int,
           :y, :int,
           :z, :int,
           :w, :int,
           :dx, :int,
           :dy, :int,
           :dz, :int,
           :dw, :int,
           :button, :uint,
           :pressure, :float
  end

  # (Not documented)
  class AllegroTimer < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (AllegroTimer)
  # :timestamp ::
  #   (Float)
  # :count ::
  #   (Integer)
  # :error ::
  #   (Float)
  class AllegroTimerEvent < FFI::Struct
    layout :type, :uint,
           :source, AllegroTimer.by_ref,
           :timestamp, :double,
           :count, :long_long,
           :error, :double
  end

  # (Not documented)
  class AllegroUserEventDescriptor < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer)
  # :source ::
  #   (AllegroEventSource)
  # :timestamp ::
  #   (Float)
  # :internal_descr ::
  #   (AllegroUserEventDescriptor)
  # :data1 ::
  #   (Integer)
  # :data2 ::
  #   (Integer)
  # :data3 ::
  #   (Integer)
  # :data4 ::
  #   (Integer)
  class AllegroUserEvent < FFI::Struct
    layout :type, :uint,
           :source, AllegroEventSource.by_ref,
           :timestamp, :double,
           :internal_descr, AllegroUserEventDescriptor,
           :data1, :long,
           :data2, :long,
           :data3, :long,
           :data4, :long
  end

  # (Not documented)
  #
  # = Fields:
  # :type ::
  #   (Integer) This must be the same as the first field of _AL_EVENT_HEADER.
  # :any ::
  #   (AllegroAnyEvent) `any' is to allow the user to access the other fields which are
  #   common to all event types, without using some specific type
  #   structure.
  # :display ::
  #   (AllegroDisplayEvent)
  # :joystick ::
  #   (AllegroJoystickEvent)
  # :keyboard ::
  #   (AllegroKeyboardEvent)
  # :mouse ::
  #   (AllegroMouseEvent)
  # :timer ::
  #   (AllegroTimerEvent)
  # :user ::
  #   (AllegroUserEvent)
  class AllegroEvent < FFI::Union
    layout :type, :uint,
           :any, AllegroAnyEvent.by_value,
           :display, AllegroDisplayEvent.by_value,
           :joystick, AllegroJoystickEvent.by_value,
           :keyboard, AllegroKeyboardEvent.by_value,
           :mouse, AllegroMouseEvent.by_value,
           :timer, AllegroTimerEvent.by_value,
           :user, AllegroUserEvent.by_value
  end

  # (Not documented)
  #
  # @method al_init_user_event_source(allegro_event_source)
  # @param [AllegroEventSource] allegro_event_source
  # @return [nil]
  # @scope class
  attach_function :al_init_user_event_source, :al_init_user_event_source, [AllegroEventSource], :void

  # (Not documented)
  #
  # @method al_destroy_user_event_source(allegro_event_source)
  # @param [AllegroEventSource] allegro_event_source
  # @return [nil]
  # @scope class
  attach_function :al_destroy_user_event_source, :al_destroy_user_event_source, [AllegroEventSource], :void

  # (Not documented)
  #
  # @method al_emit_user_event(allegro_event_source, allegro_event, dtor)
  # @param [AllegroEventSource] allegro_event_source
  # @param [AllegroEvent] allegro_event
  # @param [FFI::Pointer(*)] dtor
  # @return [Boolean]
  # @scope class
  attach_function :al_emit_user_event, :al_emit_user_event, [AllegroEventSource, AllegroEvent, :pointer], :bool

  # (Not documented)
  #
  # @method al_unref_user_event(allegro_user_event)
  # @param [AllegroUserEvent] allegro_user_event
  # @return [nil]
  # @scope class
  attach_function :al_unref_user_event, :al_unref_user_event, [AllegroUserEvent], :void

  # (Not documented)
  #
  # @method al_set_event_source_data(allegro_event_source, data)
  # @param [AllegroEventSource] allegro_event_source
  # @param [Integer] data
  # @return [nil]
  # @scope class
  attach_function :al_set_event_source_data, :al_set_event_source_data, [AllegroEventSource, :long], :void

  # (Not documented)
  #
  # @method al_get_event_source_data(allegro_event_source)
  # @param [AllegroEventSource] allegro_event_source
  # @return [Integer]
  # @scope class
  attach_function :al_get_event_source_data, :al_get_event_source_data, [AllegroEventSource], :long

  # (Not documented)
  class AllegroEventQueue < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # @method al_create_event_queue()
  # @return [AllegroEventQueue]
  # @scope class
  attach_function :al_create_event_queue, :al_create_event_queue, [], AllegroEventQueue

  # (Not documented)
  #
  # @method al_destroy_event_queue(allegro_event_queue)
  # @param [AllegroEventQueue] allegro_event_queue
  # @return [nil]
  # @scope class
  attach_function :al_destroy_event_queue, :al_destroy_event_queue, [AllegroEventQueue], :void

  # (Not documented)
  #
  # @method al_register_event_source(allegro_event_queue, allegro_event_source)
  # @param [AllegroEventQueue] allegro_event_queue
  # @param [AllegroEventSource] allegro_event_source
  # @return [nil]
  # @scope class
  attach_function :al_register_event_source, :al_register_event_source, [AllegroEventQueue, AllegroEventSource], :void

  # (Not documented)
  #
  # @method al_unregister_event_source(allegro_event_queue, allegro_event_source)
  # @param [AllegroEventQueue] allegro_event_queue
  # @param [AllegroEventSource] allegro_event_source
  # @return [nil]
  # @scope class
  attach_function :al_unregister_event_source, :al_unregister_event_source, [AllegroEventQueue, AllegroEventSource], :void

  # (Not documented)
  #
  # @method al_is_event_queue_empty(allegro_event_queue)
  # @param [AllegroEventQueue] allegro_event_queue
  # @return [Boolean]
  # @scope class
  attach_function :al_is_event_queue_empty, :al_is_event_queue_empty, [AllegroEventQueue], :bool

  # (Not documented)
  #
  # @method al_get_next_event(allegro_event_queue, ret_event)
  # @param [AllegroEventQueue] allegro_event_queue
  # @param [AllegroEvent] ret_event
  # @return [Boolean]
  # @scope class
  attach_function :al_get_next_event, :al_get_next_event, [AllegroEventQueue, AllegroEvent], :bool

  # (Not documented)
  #
  # @method al_peek_next_event(allegro_event_queue, ret_event)
  # @param [AllegroEventQueue] allegro_event_queue
  # @param [AllegroEvent] ret_event
  # @return [Boolean]
  # @scope class
  attach_function :al_peek_next_event, :al_peek_next_event, [AllegroEventQueue, AllegroEvent], :bool

  # (Not documented)
  #
  # @method al_drop_next_event(allegro_event_queue)
  # @param [AllegroEventQueue] allegro_event_queue
  # @return [Boolean]
  # @scope class
  attach_function :al_drop_next_event, :al_drop_next_event, [AllegroEventQueue], :bool

  # (Not documented)
  #
  # @method al_flush_event_queue(allegro_event_queue)
  # @param [AllegroEventQueue] allegro_event_queue
  # @return [nil]
  # @scope class
  attach_function :al_flush_event_queue, :al_flush_event_queue, [AllegroEventQueue], :void

  # (Not documented)
  #
  # @method al_wait_for_event(allegro_event_queue, ret_event)
  # @param [AllegroEventQueue] allegro_event_queue
  # @param [AllegroEvent] ret_event
  # @return [nil]
  # @scope class
  attach_function :al_wait_for_event, :al_wait_for_event, [AllegroEventQueue, AllegroEvent], :void

  # (Not documented)
  #
  # @method al_wait_for_event_timed(allegro_event_queue, ret_event, secs)
  # @param [AllegroEventQueue] allegro_event_queue
  # @param [AllegroEvent] ret_event
  # @param [Float] secs
  # @return [Boolean]
  # @scope class
  attach_function :al_wait_for_event_timed, :al_wait_for_event_timed, [AllegroEventQueue, AllegroEvent, :float], :bool

  # (Not documented)
  #
  # @method al_wait_for_event_until(queue, ret_event, timeout)
  # @param [AllegroEventQueue] queue
  # @param [AllegroEvent] ret_event
  # @param [AllegroTimeout] timeout
  # @return [Boolean]
  # @scope class
  attach_function :al_wait_for_event_until, :al_wait_for_event_until, [AllegroEventQueue, AllegroEvent, AllegroTimeout], :bool

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_display_options).</em>
  #
  # === Options:
  # :allegro_red_size ::
  #
  # :allegro_green_size ::
  #
  # :allegro_blue_size ::
  #
  # :allegro_alpha_size ::
  #
  # :allegro_red_shift ::
  #
  # :allegro_green_shift ::
  #
  # :allegro_blue_shift ::
  #
  # :allegro_alpha_shift ::
  #
  # :allegro_acc_red_size ::
  #
  # :allegro_acc_green_size ::
  #
  # :allegro_acc_blue_size ::
  #
  # :allegro_acc_alpha_size ::
  #
  # :allegro_stereo ::
  #
  # :allegro_aux_buffers ::
  #
  # :allegro_color_size ::
  #
  # :allegro_depth_size ::
  #
  # :allegro_stencil_size ::
  #
  # :allegro_sample_buffers ::
  #
  # :allegro_samples ::
  #
  # :allegro_render_method ::
  #
  # :allegro_float_color ::
  #
  # :allegro_float_depth ::
  #
  # :allegro_single_buffer ::
  #
  # :allegro_swap_method ::
  #
  # :allegro_compatible_display ::
  #
  # :allegro_update_display_region ::
  #
  # :allegro_vsync ::
  #
  # :allegro_max_bitmap_size ::
  #
  # :allegro_support_npot_bitmap ::
  #
  # :allegro_can_draw_into_bitmap ::
  #
  # :allegro_support_separate_alpha ::
  #
  # :allegro_display_options_count ::
  #
  #
  # @method _enum_allegro_display_options_
  # @return [Symbol]
  # @scope class
  enum :allegro_display_options, [
    :allegro_red_size, 0,
    :allegro_green_size, 1,
    :allegro_blue_size, 2,
    :allegro_alpha_size, 3,
    :allegro_red_shift, 4,
    :allegro_green_shift, 5,
    :allegro_blue_shift, 6,
    :allegro_alpha_shift, 7,
    :allegro_acc_red_size, 8,
    :allegro_acc_green_size, 9,
    :allegro_acc_blue_size, 10,
    :allegro_acc_alpha_size, 11,
    :allegro_stereo, 12,
    :allegro_aux_buffers, 13,
    :allegro_color_size, 14,
    :allegro_depth_size, 15,
    :allegro_stencil_size, 16,
    :allegro_sample_buffers, 17,
    :allegro_samples, 18,
    :allegro_render_method, 19,
    :allegro_float_color, 20,
    :allegro_float_depth, 21,
    :allegro_single_buffer, 22,
    :allegro_swap_method, 23,
    :allegro_compatible_display, 24,
    :allegro_update_display_region, 25,
    :allegro_vsync, 26,
    :allegro_max_bitmap_size, 27,
    :allegro_support_npot_bitmap, 28,
    :allegro_can_draw_into_bitmap, 29,
    :allegro_support_separate_alpha, 30,
    :allegro_display_options_count, 31
  ]

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_display_orientation).</em>
  #
  # === Options:
  # :allegro_display_orientation_0_degrees ::
  #
  # :allegro_display_orientation_90_degrees ::
  #
  # :allegro_display_orientation_180_degrees ::
  #
  # :allegro_display_orientation_270_degrees ::
  #
  # :allegro_display_orientation_face_up ::
  #
  # :allegro_display_orientation_face_down ::
  #
  #
  # @method _enum_allegro_display_orientation_
  # @return [Symbol]
  # @scope class
  enum :allegro_display_orientation, [
    :allegro_display_orientation_0_degrees, 0,
    :allegro_display_orientation_90_degrees, 1,
    :allegro_display_orientation_180_degrees, 2,
    :allegro_display_orientation_270_degrees, 3,
    :allegro_display_orientation_face_up, 4,
    :allegro_display_orientation_face_down, 5
  ]

  # (Not documented)
  #
  # @method al_set_new_display_refresh_rate(refresh_rate)
  # @param [Integer] refresh_rate
  # @return [nil]
  # @scope class
  attach_function :al_set_new_display_refresh_rate, :al_set_new_display_refresh_rate, [:int], :void

  # (Not documented)
  #
  # @method al_set_new_display_flags(flags)
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_set_new_display_flags, :al_set_new_display_flags, [:int], :void

  # (Not documented)
  #
  # @method al_get_new_display_refresh_rate()
  # @return [Integer]
  # @scope class
  attach_function :al_get_new_display_refresh_rate, :al_get_new_display_refresh_rate, [], :int

  # (Not documented)
  #
  # @method al_get_new_display_flags()
  # @return [Integer]
  # @scope class
  attach_function :al_get_new_display_flags, :al_get_new_display_flags, [], :int

  # (Not documented)
  #
  # @method al_get_display_width(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Integer]
  # @scope class
  attach_function :al_get_display_width, :al_get_display_width, [:pointer], :int

  # (Not documented)
  #
  # @method al_get_display_height(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Integer]
  # @scope class
  attach_function :al_get_display_height, :al_get_display_height, [:pointer], :int

  # (Not documented)
  #
  # @method al_get_display_format(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Integer]
  # @scope class
  attach_function :al_get_display_format, :al_get_display_format, [:pointer], :allegro_pixel_format

  # (Not documented)
  #
  # @method al_get_display_refresh_rate(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Integer]
  # @scope class
  attach_function :al_get_display_refresh_rate, :al_get_display_refresh_rate, [:pointer], :int

  # (Not documented)
  #
  # @method al_get_display_flags(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Integer]
  # @scope class
  attach_function :al_get_display_flags, :al_get_display_flags, [:pointer], :int

  # (Not documented)
  #
  # @method al_set_display_flag(display, flag, onoff)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] flag
  # @param [Boolean] onoff
  # @return [Boolean]
  # @scope class
  attach_function :al_set_display_flag, :al_set_display_flag, [:pointer, :int, :bool], :bool

  # (Not documented)
  #
  # @method al_toggle_display_flag(display, flag, onoff)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] flag
  # @param [Boolean] onoff
  # @return [Boolean]
  # @scope class
  attach_function :al_toggle_display_flag, :al_toggle_display_flag, [:pointer, :int, :bool], :bool

  # (Not documented)
  #
  # @method al_create_display(w, h)
  # @param [Integer] w
  # @param [Integer] h
  # @return [FFI::Pointer(*AllegroDisplay)]
  # @scope class
  attach_function :al_create_display, :al_create_display, [:int, :int], :pointer

  # (Not documented)
  #
  # @method al_destroy_display(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [nil]
  # @scope class
  attach_function :al_destroy_display, :al_destroy_display, [:pointer], :void

  # (Not documented)
  #
  # @method al_get_current_display()
  # @return [FFI::Pointer(*AllegroDisplay)]
  # @scope class
  attach_function :al_get_current_display, :al_get_current_display, [], :pointer

  # (Not documented)
  #
  # @method al_set_target_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [nil]
  # @scope class
  attach_function :al_set_target_bitmap, :al_set_target_bitmap, [:pointer], :void

  # (Not documented)
  #
  # @method al_set_target_backbuffer(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [nil]
  # @scope class
  attach_function :al_set_target_backbuffer, :al_set_target_backbuffer, [:pointer], :void

  # (Not documented)
  #
  # @method al_get_backbuffer(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_get_backbuffer, :al_get_backbuffer, [:pointer], :pointer

  # (Not documented)
  #
  # @method al_get_target_bitmap()
  # @return [FFI::Pointer(*AllegroBitmap)]
  # @scope class
  attach_function :al_get_target_bitmap, :al_get_target_bitmap, [], :pointer

  # (Not documented)
  #
  # @method al_acknowledge_resize(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Boolean]
  # @scope class
  attach_function :al_acknowledge_resize, :al_acknowledge_resize, [:pointer], :bool

  # (Not documented)
  #
  # @method al_resize_display(display, width, height)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] width
  # @param [Integer] height
  # @return [Boolean]
  # @scope class
  attach_function :al_resize_display, :al_resize_display, [:pointer, :int, :int], :bool

  # (Not documented)
  #
  # @method al_flip_display()
  # @return [nil]
  # @scope class
  attach_function :al_flip_display, :al_flip_display, [], :void

  # (Not documented)
  #
  # @method al_update_display_region(x, y, width, height)
  # @param [Integer] x
  # @param [Integer] y
  # @param [Integer] width
  # @param [Integer] height
  # @return [nil]
  # @scope class
  attach_function :al_update_display_region, :al_update_display_region, [:int, :int, :int, :int], :void

  # (Not documented)
  #
  # @method al_is_compatible_bitmap(bitmap)
  # @param [FFI::Pointer(*AllegroBitmap)] bitmap
  # @return [Boolean]
  # @scope class
  attach_function :al_is_compatible_bitmap, :al_is_compatible_bitmap, [:pointer], :bool

  # (Not documented)
  #
  # @method al_wait_for_vsync()
  # @return [Boolean]
  # @scope class
  attach_function :al_wait_for_vsync, :al_wait_for_vsync, [], :bool

  # (Not documented)
  #
  # @method al_get_display_event_source(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [AllegroEventSource]
  # @scope class
  attach_function :al_get_display_event_source, :al_get_display_event_source, [:pointer], AllegroEventSource

  # (Not documented)
  #
  # @method al_set_display_icon(display, icon)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [FFI::Pointer(*AllegroBitmap)] icon
  # @return [nil]
  # @scope class
  attach_function :al_set_display_icon, :al_set_display_icon, [:pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_set_display_icons(display, num_icons, icons)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] num_icons
  # @param [FFI::Pointer(*AllegroBitmap)] icons
  # @return [nil]
  # @scope class
  attach_function :al_set_display_icons, :al_set_display_icons, [:pointer, :int, :pointer], :void

  # (Not documented)
  #
  # @method al_get_new_display_adapter()
  # @return [Integer]
  # @scope class
  attach_function :al_get_new_display_adapter, :al_get_new_display_adapter, [], :int

  # (Not documented)
  #
  # @method al_set_new_display_adapter(adapter)
  # @param [Integer] adapter
  # @return [nil]
  # @scope class
  attach_function :al_set_new_display_adapter, :al_set_new_display_adapter, [:int], :void

  # (Not documented)
  #
  # @method al_set_new_window_position(x, y)
  # @param [Integer] x
  # @param [Integer] y
  # @return [nil]
  # @scope class
  attach_function :al_set_new_window_position, :al_set_new_window_position, [:int, :int], :void

  # (Not documented)
  #
  # @method al_get_new_window_position(x, y)
  # @param [FFI::Pointer(*Int)] x
  # @param [FFI::Pointer(*Int)] y
  # @return [nil]
  # @scope class
  attach_function :al_get_new_window_position, :al_get_new_window_position, [:pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_set_window_position(display, x, y)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] x
  # @param [Integer] y
  # @return [nil]
  # @scope class
  attach_function :al_set_window_position, :al_set_window_position, [:pointer, :int, :int], :void

  # (Not documented)
  #
  # @method al_get_window_position(display, x, y)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [FFI::Pointer(*Int)] x
  # @param [FFI::Pointer(*Int)] y
  # @return [nil]
  # @scope class
  attach_function :al_get_window_position, :al_get_window_position, [:pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_set_window_title(display, title)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [String] title
  # @return [nil]
  # @scope class
  attach_function :al_set_window_title, :al_set_window_title, [:pointer, :string], :void

  # (Not documented)
  #
  # @method al_set_new_display_option(option, value, importance)
  # @param [Integer] option
  # @param [Integer] value
  # @param [Integer] importance
  # @return [nil]
  # @scope class
  attach_function :al_set_new_display_option, :al_set_new_display_option, [:int, :int, :int], :void

  # (Not documented)
  #
  # @method al_get_new_display_option(option, importance)
  # @param [Integer] option
  # @param [FFI::Pointer(*Int)] importance
  # @return [Integer]
  # @scope class
  attach_function :al_get_new_display_option, :al_get_new_display_option, [:int, :pointer], :int

  # (Not documented)
  #
  # @method al_reset_new_display_options()
  # @return [nil]
  # @scope class
  attach_function :al_reset_new_display_options, :al_reset_new_display_options, [], :void

  # (Not documented)
  #
  # @method al_get_display_option(display, option)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] option
  # @return [Integer]
  # @scope class
  attach_function :al_get_display_option, :al_get_display_option, [:pointer, :int], :int

  # (Not documented)
  #
  # @method al_hold_bitmap_drawing(hold)
  # @param [Boolean] hold
  # @return [nil]
  # @scope class
  attach_function :al_hold_bitmap_drawing, :al_hold_bitmap_drawing, [:bool], :void

  # (Not documented)
  #
  # @method al_is_bitmap_drawing_held()
  # @return [Boolean]
  # @scope class
  attach_function :al_is_bitmap_drawing_held, :al_is_bitmap_drawing_held, [], :bool

  # (Not documented)
  #
  # @method al_clear_to_color(color)
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_clear_to_color, :al_clear_to_color, [AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_draw_pixel(x, y, color)
  # @param [Float] x
  # @param [Float] y
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_pixel, :al_draw_pixel, [:float, :float, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_get_errno()
  # @return [Integer]
  # @scope class
  attach_function :al_get_errno, :al_get_errno, [], :int

  # (Not documented)
  #
  # @method al_set_errno(errnum)
  # @param [Integer] errnum
  # @return [nil]
  # @scope class
  attach_function :al_set_errno, :al_set_errno, [:int], :void

  # (Not documented)
  #
  # @method al_fixsqrt(x)
  # @param [Integer] x
  # @return [Integer]
  # @scope class
  attach_function :al_fixsqrt, :al_fixsqrt, [:int], :int

  # (Not documented)
  #
  # @method al_fixhypot(x, y)
  # @param [Integer] x
  # @param [Integer] y
  # @return [Integer]
  # @scope class
  attach_function :al_fixhypot, :al_fixhypot, [:int, :int], :int

  # (Not documented)
  #
  # @method al_fixatan(x)
  # @param [Integer] x
  # @return [Integer]
  # @scope class
  attach_function :al_fixatan, :al_fixatan, [:int], :int

  # (Not documented)
  #
  # @method al_fixatan2(y, x)
  # @param [Integer] y
  # @param [Integer] x
  # @return [Integer]
  # @scope class
  attach_function :al_fixatan2, :al_fixatan2, [:int, :int], :int

  # (Not documented)
  #
  # = Fields:
  # :vtable ::
  #   (FFI::Pointer(*AllegroFsInterface))
  class AllegroFsEntry < FFI::Struct
    layout :vtable, :pointer
  end

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_file_mode).</em>
  #
  # === Options:
  # :allegro_filemode_read ::
  #
  # :allegro_filemode_write ::
  #
  # :allegro_filemode_execute ::
  #
  # :allegro_filemode_hidden ::
  #
  # :allegro_filemode_isfile ::
  #
  # :allegro_filemode_isdir ::
  #
  #
  # @method _enum_allegro_file_mode_
  # @return [Symbol]
  # @scope class
  enum :allegro_file_mode, [
    :allegro_filemode_read, 1,
    :allegro_filemode_write, 2,
    :allegro_filemode_execute, 4,
    :allegro_filemode_hidden, 8,
    :allegro_filemode_isfile, 16,
    :allegro_filemode_isdir, 32
  ]

  # (Not documented)
  #
  # = Fields:
  # :fs_create_entry ::
  #   (FFI::Pointer(*))
  # :fs_destroy_entry ::
  #   (FFI::Pointer(*))
  # :fs_entry_name ::
  #   (FFI::Pointer(*))
  # :fs_update_entry ::
  #   (FFI::Pointer(*))
  # :fs_entry_mode ::
  #   (FFI::Pointer(*))
  # :fs_entry_atime ::
  #   (FFI::Pointer(*))
  # :fs_entry_mtime ::
  #   (FFI::Pointer(*))
  # :fs_entry_ctime ::
  #   (FFI::Pointer(*))
  # :fs_entry_size ::
  #   (FFI::Pointer(*))
  # :fs_entry_exists ::
  #   (FFI::Pointer(*))
  # :fs_remove_entry ::
  #   (FFI::Pointer(*))
  # :fs_open_directory ::
  #   (FFI::Pointer(*))
  # :fs_read_directory ::
  #   (FFI::Pointer(*))
  # :fs_close_directory ::
  #   (FFI::Pointer(*))
  # :fs_filename_exists ::
  #   (FFI::Pointer(*))
  # :fs_remove_filename ::
  #   (FFI::Pointer(*))
  # :fs_get_current_directory ::
  #   (FFI::Pointer(*))
  # :fs_change_directory ::
  #   (FFI::Pointer(*))
  # :fs_make_directory ::
  #   (FFI::Pointer(*))
  # :fs_open_file ::
  #   (FFI::Pointer(*))
  class AllegroFsInterface < FFI::Struct
    layout :fs_create_entry, :pointer,
           :fs_destroy_entry, :pointer,
           :fs_entry_name, :pointer,
           :fs_update_entry, :pointer,
           :fs_entry_mode, :pointer,
           :fs_entry_atime, :pointer,
           :fs_entry_mtime, :pointer,
           :fs_entry_ctime, :pointer,
           :fs_entry_size, :pointer,
           :fs_entry_exists, :pointer,
           :fs_remove_entry, :pointer,
           :fs_open_directory, :pointer,
           :fs_read_directory, :pointer,
           :fs_close_directory, :pointer,
           :fs_filename_exists, :pointer,
           :fs_remove_filename, :pointer,
           :fs_get_current_directory, :pointer,
           :fs_change_directory, :pointer,
           :fs_make_directory, :pointer,
           :fs_open_file, :pointer
  end

  # (Not documented)
  #
  # @method al_create_fs_entry(path)
  # @param [String] path
  # @return [AllegroFsEntry]
  # @scope class
  attach_function :al_create_fs_entry, :al_create_fs_entry, [:string], AllegroFsEntry

  # (Not documented)
  #
  # @method al_destroy_fs_entry(e)
  # @param [AllegroFsEntry] e
  # @return [nil]
  # @scope class
  attach_function :al_destroy_fs_entry, :al_destroy_fs_entry, [AllegroFsEntry], :void

  # (Not documented)
  #
  # @method al_get_fs_entry_name(e)
  # @param [AllegroFsEntry] e
  # @return [String]
  # @scope class
  attach_function :al_get_fs_entry_name, :al_get_fs_entry_name, [AllegroFsEntry], :string

  # (Not documented)
  #
  # @method al_update_fs_entry(e)
  # @param [AllegroFsEntry] e
  # @return [Boolean]
  # @scope class
  attach_function :al_update_fs_entry, :al_update_fs_entry, [AllegroFsEntry], :bool

  # (Not documented)
  #
  # @method al_get_fs_entry_mode(e)
  # @param [AllegroFsEntry] e
  # @return [Integer]
  # @scope class
  attach_function :al_get_fs_entry_mode, :al_get_fs_entry_mode, [AllegroFsEntry], :uint

  # (Not documented)
  #
  # @method al_get_fs_entry_atime(e)
  # @param [AllegroFsEntry] e
  # @return [Integer]
  # @scope class
  attach_function :al_get_fs_entry_atime, :al_get_fs_entry_atime, [AllegroFsEntry], :long

  # (Not documented)
  #
  # @method al_get_fs_entry_mtime(e)
  # @param [AllegroFsEntry] e
  # @return [Integer]
  # @scope class
  attach_function :al_get_fs_entry_mtime, :al_get_fs_entry_mtime, [AllegroFsEntry], :long

  # (Not documented)
  #
  # @method al_get_fs_entry_ctime(e)
  # @param [AllegroFsEntry] e
  # @return [Integer]
  # @scope class
  attach_function :al_get_fs_entry_ctime, :al_get_fs_entry_ctime, [AllegroFsEntry], :long

  # (Not documented)
  #
  # @method al_get_fs_entry_size(e)
  # @param [AllegroFsEntry] e
  # @return [Integer]
  # @scope class
  attach_function :al_get_fs_entry_size, :al_get_fs_entry_size, [AllegroFsEntry], :long_long

  # (Not documented)
  #
  # @method al_fs_entry_exists(e)
  # @param [AllegroFsEntry] e
  # @return [Boolean]
  # @scope class
  attach_function :al_fs_entry_exists, :al_fs_entry_exists, [AllegroFsEntry], :bool

  # (Not documented)
  #
  # @method al_remove_fs_entry(e)
  # @param [AllegroFsEntry] e
  # @return [Boolean]
  # @scope class
  attach_function :al_remove_fs_entry, :al_remove_fs_entry, [AllegroFsEntry], :bool

  # (Not documented)
  #
  # @method al_open_directory(e)
  # @param [AllegroFsEntry] e
  # @return [Boolean]
  # @scope class
  attach_function :al_open_directory, :al_open_directory, [AllegroFsEntry], :bool

  # (Not documented)
  #
  # @method al_read_directory(e)
  # @param [AllegroFsEntry] e
  # @return [AllegroFsEntry]
  # @scope class
  attach_function :al_read_directory, :al_read_directory, [AllegroFsEntry], AllegroFsEntry

  # (Not documented)
  #
  # @method al_close_directory(e)
  # @param [AllegroFsEntry] e
  # @return [Boolean]
  # @scope class
  attach_function :al_close_directory, :al_close_directory, [AllegroFsEntry], :bool

  # (Not documented)
  #
  # @method al_filename_exists(path)
  # @param [String] path
  # @return [Boolean]
  # @scope class
  attach_function :al_filename_exists, :al_filename_exists, [:string], :bool

  # (Not documented)
  #
  # @method al_remove_filename(path)
  # @param [String] path
  # @return [Boolean]
  # @scope class
  attach_function :al_remove_filename, :al_remove_filename, [:string], :bool

  # (Not documented)
  #
  # @method al_get_current_directory()
  # @return [String]
  # @scope class
  attach_function :al_get_current_directory, :al_get_current_directory, [], :string

  # (Not documented)
  #
  # @method al_change_directory(path)
  # @param [String] path
  # @return [Boolean]
  # @scope class
  attach_function :al_change_directory, :al_change_directory, [:string], :bool

  # (Not documented)
  #
  # @method al_make_directory(path)
  # @param [String] path
  # @return [Boolean]
  # @scope class
  attach_function :al_make_directory, :al_make_directory, [:string], :bool

  # (Not documented)
  #
  # @method al_open_fs_entry(e, mode)
  # @param [AllegroFsEntry] e
  # @param [String] mode
  # @return [AllegroFile]
  # @scope class
  attach_function :al_open_fs_entry, :al_open_fs_entry, [AllegroFsEntry, :string], AllegroFile

  # (Not documented)
  #
  # @method al_get_fs_interface()
  # @return [AllegroFsInterface]
  # @scope class
  attach_function :al_get_fs_interface, :al_get_fs_interface, [], AllegroFsInterface

  # (Not documented)
  #
  # @method al_set_fs_interface(vtable)
  # @param [AllegroFsInterface] vtable
  # @return [nil]
  # @scope class
  attach_function :al_set_fs_interface, :al_set_fs_interface, [AllegroFsInterface], :void

  # (Not documented)
  #
  # @method al_set_standard_fs_interface()
  # @return [nil]
  # @scope class
  attach_function :al_set_standard_fs_interface, :al_set_standard_fs_interface, [], :void

  # (Not documented)
  #
  # = Fields:
  # :width ::
  #   (Integer)
  # :height ::
  #   (Integer)
  # :format ::
  #   (Integer)
  # :refresh_rate ::
  #   (Integer)
  class AllegroDisplayMode < FFI::Struct
    layout :width, :int,
           :height, :int,
           :format, :int,
           :refresh_rate, :int
  end

  # (Not documented)
  #
  # @method al_get_num_display_modes()
  # @return [Integer]
  # @scope class
  attach_function :al_get_num_display_modes, :al_get_num_display_modes, [], :int

  # (Not documented)
  #
  # @method al_get_display_mode(index, mode)
  # @param [Integer] index
  # @param [AllegroDisplayMode] mode
  # @return [AllegroDisplayMode]
  # @scope class
  attach_function :al_get_display_mode, :al_get_display_mode, [:int, AllegroDisplayMode], AllegroDisplayMode

  # (Not documented)
  #
  # = Fields:
  # :axis ::
  #   (Array<Float>) -1.0 to 1.0
  class AllegroJoystickStateStick < FFI::Struct
    layout :axis, [:float, 3]
  end

  # (Not documented)
  #
  # = Fields:
  # :stick ::
  #   (Array<AllegroJoystickStateStick>)
  # :button ::
  #   (Array<Integer>) 0 to 32767
  class AllegroJoystickState < FFI::Struct
    layout :stick, [AllegroJoystickStateStick.by_value, 8],
           :button, [:int, 32]
  end

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_joyflags).</em>
  #
  # === Options:
  # :allegro_joyflag_digital ::
  #
  # :allegro_joyflag_analogue ::
  #
  #
  # @method _enum_allegro_joyflags_
  # @return [Symbol]
  # @scope class
  enum :allegro_joyflags, [
    :allegro_joyflag_digital, 1,
    :allegro_joyflag_analogue, 2
  ]

  # (Not documented)
  #
  # @method al_install_joystick()
  # @return [Boolean]
  # @scope class
  attach_function :al_install_joystick, :al_install_joystick, [], :bool

  # (Not documented)
  #
  # @method al_uninstall_joystick()
  # @return [nil]
  # @scope class
  attach_function :al_uninstall_joystick, :al_uninstall_joystick, [], :void

  # (Not documented)
  #
  # @method al_is_joystick_installed()
  # @return [Boolean]
  # @scope class
  attach_function :al_is_joystick_installed, :al_is_joystick_installed, [], :bool

  # (Not documented)
  #
  # @method al_reconfigure_joysticks()
  # @return [Boolean]
  # @scope class
  attach_function :al_reconfigure_joysticks, :al_reconfigure_joysticks, [], :bool

  # (Not documented)
  #
  # @method al_get_num_joysticks()
  # @return [Integer]
  # @scope class
  attach_function :al_get_num_joysticks, :al_get_num_joysticks, [], :int

  # (Not documented)
  #
  # @method al_get_joystick(joyn)
  # @param [Integer] joyn
  # @return [AllegroJoystick]
  # @scope class
  attach_function :al_get_joystick, :al_get_joystick, [:int], AllegroJoystick

  # (Not documented)
  #
  # @method al_release_joystick(allegro_joystick)
  # @param [AllegroJoystick] allegro_joystick
  # @return [nil]
  # @scope class
  attach_function :al_release_joystick, :al_release_joystick, [AllegroJoystick], :void

  # (Not documented)
  #
  # @method al_get_joystick_active(allegro_joystick)
  # @param [AllegroJoystick] allegro_joystick
  # @return [Boolean]
  # @scope class
  attach_function :al_get_joystick_active, :al_get_joystick_active, [AllegroJoystick], :bool

  # (Not documented)
  #
  # @method al_get_joystick_name(allegro_joystick)
  # @param [AllegroJoystick] allegro_joystick
  # @return [String]
  # @scope class
  attach_function :al_get_joystick_name, :al_get_joystick_name, [AllegroJoystick], :string

  # (Not documented)
  #
  # @method al_get_joystick_num_sticks(allegro_joystick)
  # @param [AllegroJoystick] allegro_joystick
  # @return [Integer]
  # @scope class
  attach_function :al_get_joystick_num_sticks, :al_get_joystick_num_sticks, [AllegroJoystick], :int

  # (Not documented)
  #
  # @method al_get_joystick_stick_flags(allegro_joystick, stick)
  # @param [AllegroJoystick] allegro_joystick
  # @param [Integer] stick
  # @return [Integer]
  # @scope class
  attach_function :al_get_joystick_stick_flags, :al_get_joystick_stick_flags, [AllegroJoystick, :int], :int

  # (Not documented)
  #
  # @method al_get_joystick_stick_name(allegro_joystick, stick)
  # @param [AllegroJoystick] allegro_joystick
  # @param [Integer] stick
  # @return [String]
  # @scope class
  attach_function :al_get_joystick_stick_name, :al_get_joystick_stick_name, [AllegroJoystick, :int], :string

  # (Not documented)
  #
  # @method al_get_joystick_num_axes(allegro_joystick, stick)
  # @param [AllegroJoystick] allegro_joystick
  # @param [Integer] stick
  # @return [Integer]
  # @scope class
  attach_function :al_get_joystick_num_axes, :al_get_joystick_num_axes, [AllegroJoystick, :int], :int

  # (Not documented)
  #
  # @method al_get_joystick_axis_name(allegro_joystick, stick, axis)
  # @param [AllegroJoystick] allegro_joystick
  # @param [Integer] stick
  # @param [Integer] axis
  # @return [String]
  # @scope class
  attach_function :al_get_joystick_axis_name, :al_get_joystick_axis_name, [AllegroJoystick, :int, :int], :string

  # (Not documented)
  #
  # @method al_get_joystick_num_buttons(allegro_joystick)
  # @param [AllegroJoystick] allegro_joystick
  # @return [Integer]
  # @scope class
  attach_function :al_get_joystick_num_buttons, :al_get_joystick_num_buttons, [AllegroJoystick], :int

  # (Not documented)
  #
  # @method al_get_joystick_button_name(allegro_joystick, buttonn)
  # @param [AllegroJoystick] allegro_joystick
  # @param [Integer] buttonn
  # @return [String]
  # @scope class
  attach_function :al_get_joystick_button_name, :al_get_joystick_button_name, [AllegroJoystick, :int], :string

  # (Not documented)
  #
  # @method al_get_joystick_state(allegro_joystick, ret_state)
  # @param [AllegroJoystick] allegro_joystick
  # @param [AllegroJoystickState] ret_state
  # @return [nil]
  # @scope class
  attach_function :al_get_joystick_state, :al_get_joystick_state, [AllegroJoystick, AllegroJoystickState], :void

  # (Not documented)
  #
  # @method al_get_joystick_event_source()
  # @return [AllegroEventSource]
  # @scope class
  attach_function :al_get_joystick_event_source, :al_get_joystick_event_source, [], AllegroEventSource

  # (Not documented)
  #
  # = Fields:
  # :display ::
  #   (FFI::Pointer(*AllegroDisplay)) public
  # :key_down_internal ::
  #   (Array<Integer>) internal
  class AllegroKeyboardState < FFI::Struct
    layout :display, :pointer,
           :key_down_internal, [:uint, 8]
  end

  # (Not documented)
  #
  # @method al_is_keyboard_installed()
  # @return [Boolean]
  # @scope class
  attach_function :al_is_keyboard_installed, :al_is_keyboard_installed, [], :bool

  # (Not documented)
  #
  # @method al_install_keyboard()
  # @return [Boolean]
  # @scope class
  attach_function :al_install_keyboard, :al_install_keyboard, [], :bool

  # (Not documented)
  #
  # @method al_uninstall_keyboard()
  # @return [nil]
  # @scope class
  attach_function :al_uninstall_keyboard, :al_uninstall_keyboard, [], :void

  # (Not documented)
  #
  # @method al_set_keyboard_leds(leds)
  # @param [Integer] leds
  # @return [Boolean]
  # @scope class
  attach_function :al_set_keyboard_leds, :al_set_keyboard_leds, [:int], :bool

  # (Not documented)
  #
  # @method al_keycode_to_name(keycode)
  # @param [Integer] keycode
  # @return [String]
  # @scope class
  attach_function :al_keycode_to_name, :al_keycode_to_name, [:int], :string

  # (Not documented)
  #
  # @method al_get_keyboard_state(ret_state)
  # @param [AllegroKeyboardState] ret_state
  # @return [nil]
  # @scope class
  attach_function :al_get_keyboard_state, :al_get_keyboard_state, [AllegroKeyboardState], :void

  # (Not documented)
  #
  # @method al_key_down(allegro_keyboard_state, keycode)
  # @param [AllegroKeyboardState] allegro_keyboard_state
  # @param [Integer] keycode
  # @return [Boolean]
  # @scope class
  attach_function :al_key_down, :al_key_down, [AllegroKeyboardState, :int], :bool

  # (Not documented)
  #
  # @method al_get_keyboard_event_source()
  # @return [AllegroEventSource]
  # @scope class
  attach_function :al_get_keyboard_event_source, :al_get_keyboard_event_source, [], AllegroEventSource

  # (Not documented)
  #
  # = Fields:
  # :mi_malloc ::
  #   (FFI::Pointer(*))
  # :mi_free ::
  #   (FFI::Pointer(*))
  # :mi_realloc ::
  #   (FFI::Pointer(*))
  # :mi_calloc ::
  #   (FFI::Pointer(*))
  class AllegroMemoryInterface < FFI::Struct
    layout :mi_malloc, :pointer,
           :mi_free, :pointer,
           :mi_realloc, :pointer,
           :mi_calloc, :pointer
  end

  # (Not documented)
  #
  # @method al_set_memory_interface(iface)
  # @param [AllegroMemoryInterface] iface
  # @return [nil]
  # @scope class
  attach_function :al_set_memory_interface, :al_set_memory_interface, [AllegroMemoryInterface], :void

  # (Not documented)
  #
  # @method al_malloc_with_context(n, line, file, func)
  # @param [Integer] n
  # @param [Integer] line
  # @param [String] file
  # @param [String] func
  # @return [FFI::Pointer(*Void)]
  # @scope class
  attach_function :al_malloc_with_context, :al_malloc_with_context, [:ulong, :int, :string, :string], :pointer

  # (Not documented)
  #
  # @method al_free_with_context(ptr, line, file, func)
  # @param [FFI::Pointer(*Void)] ptr
  # @param [Integer] line
  # @param [String] file
  # @param [String] func
  # @return [nil]
  # @scope class
  attach_function :al_free_with_context, :al_free_with_context, [:pointer, :int, :string, :string], :void

  # (Not documented)
  #
  # @method al_realloc_with_context(ptr, n, line, file, func)
  # @param [FFI::Pointer(*Void)] ptr
  # @param [Integer] n
  # @param [Integer] line
  # @param [String] file
  # @param [String] func
  # @return [FFI::Pointer(*Void)]
  # @scope class
  attach_function :al_realloc_with_context, :al_realloc_with_context, [:pointer, :ulong, :int, :string, :string], :pointer

  # (Not documented)
  #
  # @method al_calloc_with_context(count, n, line, file, func)
  # @param [Integer] count
  # @param [Integer] n
  # @param [Integer] line
  # @param [String] file
  # @param [String] func
  # @return [FFI::Pointer(*Void)]
  # @scope class
  attach_function :al_calloc_with_context, :al_calloc_with_context, [:ulong, :ulong, :int, :string, :string], :pointer

  # (Not documented)
  #
  # = Fields:
  # :x1 ::
  #   (Integer)
  # :y1 ::
  #   (Integer)
  # :x2 ::
  #   (Integer)
  # :y2 ::
  #   (Integer)
  class AllegroMonitorInfo < FFI::Struct
    layout :x1, :int,
           :y1, :int,
           :x2, :int,
           :y2, :int
  end

  # (Not documented)
  #
  # @method al_get_num_video_adapters()
  # @return [Integer]
  # @scope class
  attach_function :al_get_num_video_adapters, :al_get_num_video_adapters, [], :int

  # (Not documented)
  #
  # @method al_get_monitor_info(adapter, info)
  # @param [Integer] adapter
  # @param [AllegroMonitorInfo] info
  # @return [Boolean]
  # @scope class
  attach_function :al_get_monitor_info, :al_get_monitor_info, [:int, AllegroMonitorInfo], :bool

  # (Not documented)
  #
  # = Fields:
  # :x ::
  #   (Integer) (x, y) Primary mouse position
  #   (z) Mouse wheel position (1D 'wheel'), or,
  #   (w, z) Mouse wheel position (2D 'ball')
  #   display - the display the mouse is on (coordinates are relative to this)
  #   pressure - the pressure appleid to the mouse (for stylus/tablet)
  # :y ::
  #   (Integer)
  # :z ::
  #   (Integer)
  # :w ::
  #   (Integer)
  # :more_axes ::
  #   (Array<Integer>)
  # :buttons ::
  #   (Integer)
  # :pressure ::
  #   (Float)
  # :display ::
  #   (FFI::Pointer(*AllegroDisplay))
  class AllegroMouseState < FFI::Struct
    layout :x, :int,
           :y, :int,
           :z, :int,
           :w, :int,
           :more_axes, [:int, 4],
           :buttons, :int,
           :pressure, :float,
           :display, :pointer
  end

  # (Not documented)
  #
  # @method al_is_mouse_installed()
  # @return [Boolean]
  # @scope class
  attach_function :al_is_mouse_installed, :al_is_mouse_installed, [], :bool

  # (Not documented)
  #
  # @method al_install_mouse()
  # @return [Boolean]
  # @scope class
  attach_function :al_install_mouse, :al_install_mouse, [], :bool

  # (Not documented)
  #
  # @method al_uninstall_mouse()
  # @return [nil]
  # @scope class
  attach_function :al_uninstall_mouse, :al_uninstall_mouse, [], :void

  # (Not documented)
  #
  # @method al_get_mouse_num_buttons()
  # @return [Integer]
  # @scope class
  attach_function :al_get_mouse_num_buttons, :al_get_mouse_num_buttons, [], :uint

  # (Not documented)
  #
  # @method al_get_mouse_num_axes()
  # @return [Integer]
  # @scope class
  attach_function :al_get_mouse_num_axes, :al_get_mouse_num_axes, [], :uint

  # (Not documented)
  #
  # @method al_set_mouse_xy(display, x, y)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @param [Integer] x
  # @param [Integer] y
  # @return [Boolean]
  # @scope class
  attach_function :al_set_mouse_xy, :al_set_mouse_xy, [:pointer, :int, :int], :bool

  # (Not documented)
  #
  # @method al_set_mouse_z(z)
  # @param [Integer] z
  # @return [Boolean]
  # @scope class
  attach_function :al_set_mouse_z, :al_set_mouse_z, [:int], :bool

  # (Not documented)
  #
  # @method al_set_mouse_w(w)
  # @param [Integer] w
  # @return [Boolean]
  # @scope class
  attach_function :al_set_mouse_w, :al_set_mouse_w, [:int], :bool

  # (Not documented)
  #
  # @method al_set_mouse_axis(axis, value)
  # @param [Integer] axis
  # @param [Integer] value
  # @return [Boolean]
  # @scope class
  attach_function :al_set_mouse_axis, :al_set_mouse_axis, [:int, :int], :bool

  # (Not documented)
  #
  # @method al_get_mouse_state(ret_state)
  # @param [AllegroMouseState] ret_state
  # @return [nil]
  # @scope class
  attach_function :al_get_mouse_state, :al_get_mouse_state, [AllegroMouseState], :void

  # (Not documented)
  #
  # @method al_mouse_button_down(state, button)
  # @param [AllegroMouseState] state
  # @param [Integer] button
  # @return [Boolean]
  # @scope class
  attach_function :al_mouse_button_down, :al_mouse_button_down, [AllegroMouseState, :int], :bool

  # (Not documented)
  #
  # @method al_get_mouse_state_axis(state, axis)
  # @param [AllegroMouseState] state
  # @param [Integer] axis
  # @return [Integer]
  # @scope class
  attach_function :al_get_mouse_state_axis, :al_get_mouse_state_axis, [AllegroMouseState, :int], :int

  # (Not documented)
  #
  # @method al_get_mouse_cursor_position(ret_x, ret_y)
  # @param [FFI::Pointer(*Int)] ret_x
  # @param [FFI::Pointer(*Int)] ret_y
  # @return [Boolean]
  # @scope class
  attach_function :al_get_mouse_cursor_position, :al_get_mouse_cursor_position, [:pointer, :pointer], :bool

  # (Not documented)
  #
  # @method al_grab_mouse(display)
  # @param [FFI::Pointer(*AllegroDisplay)] display
  # @return [Boolean]
  # @scope class
  attach_function :al_grab_mouse, :al_grab_mouse, [:pointer], :bool

  # (Not documented)
  #
  # @method al_ungrab_mouse()
  # @return [Boolean]
  # @scope class
  attach_function :al_ungrab_mouse, :al_ungrab_mouse, [], :bool

  # (Not documented)
  #
  # @method al_get_mouse_event_source()
  # @return [AllegroEventSource]
  # @scope class
  attach_function :al_get_mouse_event_source, :al_get_mouse_event_source, [], AllegroEventSource

  # (Not documented)
  class AllegroMouseCursor < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_system_mouse_cursor).</em>
  #
  # === Options:
  # :allegro_system_mouse_cursor_none ::
  #
  # :allegro_system_mouse_cursor_default ::
  #
  # :allegro_system_mouse_cursor_arrow ::
  #
  # :allegro_system_mouse_cursor_busy ::
  #
  # :allegro_system_mouse_cursor_question ::
  #
  # :allegro_system_mouse_cursor_edit ::
  #
  # :allegro_system_mouse_cursor_move ::
  #
  # :allegro_system_mouse_cursor_resize_n ::
  #
  # :allegro_system_mouse_cursor_resize_w ::
  #
  # :allegro_system_mouse_cursor_resize_s ::
  #
  # :allegro_system_mouse_cursor_resize_e ::
  #
  # :allegro_system_mouse_cursor_resize_nw ::
  #
  # :allegro_system_mouse_cursor_resize_sw ::
  #
  # :allegro_system_mouse_cursor_resize_se ::
  #
  # :allegro_system_mouse_cursor_resize_ne ::
  #
  # :allegro_system_mouse_cursor_progress ::
  #
  # :allegro_system_mouse_cursor_precision ::
  #
  # :allegro_system_mouse_cursor_link ::
  #
  # :allegro_system_mouse_cursor_alt_select ::
  #
  # :allegro_system_mouse_cursor_unavailable ::
  #
  # :allegro_num_system_mouse_cursors ::
  #
  #
  # @method _enum_allegro_system_mouse_cursor_
  # @return [Symbol]
  # @scope class
  enum :allegro_system_mouse_cursor, [
    :allegro_system_mouse_cursor_none, 0,
    :allegro_system_mouse_cursor_default, 1,
    :allegro_system_mouse_cursor_arrow, 2,
    :allegro_system_mouse_cursor_busy, 3,
    :allegro_system_mouse_cursor_question, 4,
    :allegro_system_mouse_cursor_edit, 5,
    :allegro_system_mouse_cursor_move, 6,
    :allegro_system_mouse_cursor_resize_n, 7,
    :allegro_system_mouse_cursor_resize_w, 8,
    :allegro_system_mouse_cursor_resize_s, 9,
    :allegro_system_mouse_cursor_resize_e, 10,
    :allegro_system_mouse_cursor_resize_nw, 11,
    :allegro_system_mouse_cursor_resize_sw, 12,
    :allegro_system_mouse_cursor_resize_se, 13,
    :allegro_system_mouse_cursor_resize_ne, 14,
    :allegro_system_mouse_cursor_progress, 15,
    :allegro_system_mouse_cursor_precision, 16,
    :allegro_system_mouse_cursor_link, 17,
    :allegro_system_mouse_cursor_alt_select, 18,
    :allegro_system_mouse_cursor_unavailable, 19,
    :allegro_num_system_mouse_cursors, 20
  ]

  # (Not documented)
  class AllegroBitmap < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  class AllegroDisplay < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # @method al_create_mouse_cursor(sprite, xfocus, yfocus)
  # @param [AllegroBitmap] sprite
  # @param [Integer] xfocus
  # @param [Integer] yfocus
  # @return [AllegroMouseCursor]
  # @scope class
  attach_function :al_create_mouse_cursor, :al_create_mouse_cursor, [AllegroBitmap, :int, :int], AllegroMouseCursor

  # (Not documented)
  #
  # @method al_destroy_mouse_cursor(allegro_mouse_cursor)
  # @param [AllegroMouseCursor] allegro_mouse_cursor
  # @return [nil]
  # @scope class
  attach_function :al_destroy_mouse_cursor, :al_destroy_mouse_cursor, [AllegroMouseCursor], :void

  # (Not documented)
  #
  # @method al_set_mouse_cursor(display, cursor)
  # @param [AllegroDisplay] display
  # @param [AllegroMouseCursor] cursor
  # @return [Boolean]
  # @scope class
  attach_function :al_set_mouse_cursor, :al_set_mouse_cursor, [AllegroDisplay, AllegroMouseCursor], :bool

  # (Not documented)
  #
  # @method al_set_system_mouse_cursor(display, cursor_id)
  # @param [AllegroDisplay] display
  # @param [Symbol from _enum_allegro_system_mouse_cursor_] cursor_id
  # @return [Boolean]
  # @scope class
  attach_function :al_set_system_mouse_cursor, :al_set_system_mouse_cursor, [AllegroDisplay, :allegro_system_mouse_cursor], :bool

  # (Not documented)
  #
  # @method al_show_mouse_cursor(display)
  # @param [AllegroDisplay] display
  # @return [Boolean]
  # @scope class
  attach_function :al_show_mouse_cursor, :al_show_mouse_cursor, [AllegroDisplay], :bool

  # (Not documented)
  #
  # @method al_hide_mouse_cursor(display)
  # @param [AllegroDisplay] display
  # @return [Boolean]
  # @scope class
  attach_function :al_hide_mouse_cursor, :al_hide_mouse_cursor, [AllegroDisplay], :bool

  # (Not documented)
  class AllegroSystem < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # @method al_install_system(version, atexit_ptr)
  # @param [Integer] version
  # @param [FFI::Pointer(*)] atexit_ptr
  # @return [Boolean]
  # @scope class
  attach_function :al_install_system, :al_install_system, [:int, :pointer], :bool

  # (Not documented)
  #
  # @method al_uninstall_system()
  # @return [nil]
  # @scope class
  attach_function :al_uninstall_system, :al_uninstall_system, [], :void

  # (Not documented)
  #
  # @method al_is_system_installed()
  # @return [Boolean]
  # @scope class
  attach_function :al_is_system_installed, :al_is_system_installed, [], :bool

  # (Not documented)
  #
  # @method al_get_system_driver()
  # @return [AllegroSystem]
  # @scope class
  attach_function :al_get_system_driver, :al_get_system_driver, [], AllegroSystem

  # (Not documented)
  #
  # @method al_get_system_config()
  # @return [AllegroConfig]
  # @scope class
  attach_function :al_get_system_config, :al_get_system_config, [], AllegroConfig

  # (Not documented)
  #
  # @method al_get_standard_path(id)
  # @param [Integer] id
  # @return [AllegroPath]
  # @scope class
  attach_function :al_get_standard_path, :al_get_standard_path, [:int], AllegroPath

  # (Not documented)
  #
  # @method al_set_exe_name(path)
  # @param [String] path
  # @return [nil]
  # @scope class
  attach_function :al_set_exe_name, :al_set_exe_name, [:string], :void

  # (Not documented)
  #
  # @method al_set_org_name(org_name)
  # @param [String] org_name
  # @return [nil]
  # @scope class
  attach_function :al_set_org_name, :al_set_org_name, [:string], :void

  # (Not documented)
  #
  # @method al_set_app_name(app_name)
  # @param [String] app_name
  # @return [nil]
  # @scope class
  attach_function :al_set_app_name, :al_set_app_name, [:string], :void

  # (Not documented)
  #
  # @method al_get_org_name()
  # @return [String]
  # @scope class
  attach_function :al_get_org_name, :al_get_org_name, [], :string

  # (Not documented)
  #
  # @method al_get_app_name()
  # @return [String]
  # @scope class
  attach_function :al_get_app_name, :al_get_app_name, [], :string

  # (Not documented)
  #
  # @method al_inhibit_screensaver(inhibit)
  # @param [Boolean] inhibit
  # @return [Boolean]
  # @scope class
  attach_function :al_inhibit_screensaver, :al_inhibit_screensaver, [:bool], :bool

  # (Not documented)
  class AllegroThread < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  class AllegroMutex < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  class AllegroCond < FFI::Struct
    layout :dummy, :char
  end

  # (Not documented)
  #
  # @method al_create_thread(proc, arg)
  # @param [FFI::Pointer(*)] proc
  # @param [FFI::Pointer(*Void)] arg
  # @return [AllegroThread]
  # @scope class
  attach_function :al_create_thread, :al_create_thread, [:pointer, :pointer], AllegroThread

  # (Not documented)
  #
  # @method al_start_thread(outer)
  # @param [AllegroThread] outer
  # @return [nil]
  # @scope class
  attach_function :al_start_thread, :al_start_thread, [AllegroThread], :void

  # (Not documented)
  #
  # @method al_join_thread(outer, ret_value)
  # @param [AllegroThread] outer
  # @param [FFI::Pointer(**Void)] ret_value
  # @return [nil]
  # @scope class
  attach_function :al_join_thread, :al_join_thread, [AllegroThread, :pointer], :void

  # (Not documented)
  #
  # @method al_set_thread_should_stop(outer)
  # @param [AllegroThread] outer
  # @return [nil]
  # @scope class
  attach_function :al_set_thread_should_stop, :al_set_thread_should_stop, [AllegroThread], :void

  # (Not documented)
  #
  # @method al_get_thread_should_stop(outer)
  # @param [AllegroThread] outer
  # @return [Boolean]
  # @scope class
  attach_function :al_get_thread_should_stop, :al_get_thread_should_stop, [AllegroThread], :bool

  # (Not documented)
  #
  # @method al_destroy_thread(thread)
  # @param [AllegroThread] thread
  # @return [nil]
  # @scope class
  attach_function :al_destroy_thread, :al_destroy_thread, [AllegroThread], :void

  # (Not documented)
  #
  # @method al_run_detached_thread(proc, arg)
  # @param [FFI::Pointer(*)] proc
  # @param [FFI::Pointer(*Void)] arg
  # @return [nil]
  # @scope class
  attach_function :al_run_detached_thread, :al_run_detached_thread, [:pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_create_mutex()
  # @return [AllegroMutex]
  # @scope class
  attach_function :al_create_mutex, :al_create_mutex, [], AllegroMutex

  # (Not documented)
  #
  # @method al_create_mutex_recursive()
  # @return [AllegroMutex]
  # @scope class
  attach_function :al_create_mutex_recursive, :al_create_mutex_recursive, [], AllegroMutex

  # (Not documented)
  #
  # @method al_lock_mutex(mutex)
  # @param [AllegroMutex] mutex
  # @return [nil]
  # @scope class
  attach_function :al_lock_mutex, :al_lock_mutex, [AllegroMutex], :void

  # (Not documented)
  #
  # @method al_unlock_mutex(mutex)
  # @param [AllegroMutex] mutex
  # @return [nil]
  # @scope class
  attach_function :al_unlock_mutex, :al_unlock_mutex, [AllegroMutex], :void

  # (Not documented)
  #
  # @method al_destroy_mutex(mutex)
  # @param [AllegroMutex] mutex
  # @return [nil]
  # @scope class
  attach_function :al_destroy_mutex, :al_destroy_mutex, [AllegroMutex], :void

  # (Not documented)
  #
  # @method al_create_cond()
  # @return [AllegroCond]
  # @scope class
  attach_function :al_create_cond, :al_create_cond, [], AllegroCond

  # (Not documented)
  #
  # @method al_destroy_cond(cond)
  # @param [AllegroCond] cond
  # @return [nil]
  # @scope class
  attach_function :al_destroy_cond, :al_destroy_cond, [AllegroCond], :void

  # (Not documented)
  #
  # @method al_wait_cond(cond, mutex)
  # @param [AllegroCond] cond
  # @param [AllegroMutex] mutex
  # @return [nil]
  # @scope class
  attach_function :al_wait_cond, :al_wait_cond, [AllegroCond, AllegroMutex], :void

  # (Not documented)
  #
  # @method al_wait_cond_until(cond, mutex, timeout)
  # @param [AllegroCond] cond
  # @param [AllegroMutex] mutex
  # @param [AllegroTimeout] timeout
  # @return [Integer]
  # @scope class
  attach_function :al_wait_cond_until, :al_wait_cond_until, [AllegroCond, AllegroMutex, AllegroTimeout], :int

  # (Not documented)
  #
  # @method al_broadcast_cond(cond)
  # @param [AllegroCond] cond
  # @return [nil]
  # @scope class
  attach_function :al_broadcast_cond, :al_broadcast_cond, [AllegroCond], :void

  # (Not documented)
  #
  # @method al_signal_cond(cond)
  # @param [AllegroCond] cond
  # @return [nil]
  # @scope class
  attach_function :al_signal_cond, :al_signal_cond, [AllegroCond], :void

  # (Not documented)
  #
  # @method al_create_timer(speed_secs)
  # @param [Float] speed_secs
  # @return [AllegroTimer]
  # @scope class
  attach_function :al_create_timer, :al_create_timer, [:double], AllegroTimer

  # (Not documented)
  #
  # @method al_destroy_timer(timer)
  # @param [AllegroTimer] timer
  # @return [nil]
  # @scope class
  attach_function :al_destroy_timer, :al_destroy_timer, [AllegroTimer], :void

  # (Not documented)
  #
  # @method al_start_timer(timer)
  # @param [AllegroTimer] timer
  # @return [nil]
  # @scope class
  attach_function :al_start_timer, :al_start_timer, [AllegroTimer], :void

  # (Not documented)
  #
  # @method al_stop_timer(timer)
  # @param [AllegroTimer] timer
  # @return [nil]
  # @scope class
  attach_function :al_stop_timer, :al_stop_timer, [AllegroTimer], :void

  # (Not documented)
  #
  # @method al_get_timer_started(timer)
  # @param [AllegroTimer] timer
  # @return [Boolean]
  # @scope class
  attach_function :al_get_timer_started, :al_get_timer_started, [AllegroTimer], :bool

  # (Not documented)
  #
  # @method al_get_timer_speed(timer)
  # @param [AllegroTimer] timer
  # @return [Float]
  # @scope class
  attach_function :al_get_timer_speed, :al_get_timer_speed, [AllegroTimer], :double

  # (Not documented)
  #
  # @method al_set_timer_speed(timer, speed_secs)
  # @param [AllegroTimer] timer
  # @param [Float] speed_secs
  # @return [nil]
  # @scope class
  attach_function :al_set_timer_speed, :al_set_timer_speed, [AllegroTimer, :double], :void

  # (Not documented)
  #
  # @method al_get_timer_count(timer)
  # @param [AllegroTimer] timer
  # @return [Integer]
  # @scope class
  attach_function :al_get_timer_count, :al_get_timer_count, [AllegroTimer], :long_long

  # (Not documented)
  #
  # @method al_set_timer_count(timer, count)
  # @param [AllegroTimer] timer
  # @param [Integer] count
  # @return [nil]
  # @scope class
  attach_function :al_set_timer_count, :al_set_timer_count, [AllegroTimer, :long_long], :void

  # (Not documented)
  #
  # @method al_add_timer_count(timer, diff)
  # @param [AllegroTimer] timer
  # @param [Integer] diff
  # @return [nil]
  # @scope class
  attach_function :al_add_timer_count, :al_add_timer_count, [AllegroTimer, :long_long], :void

  # (Not documented)
  #
  # @method al_get_timer_event_source(timer)
  # @param [AllegroTimer] timer
  # @return [AllegroEventSource]
  # @scope class
  attach_function :al_get_timer_event_source, :al_get_timer_event_source, [AllegroTimer], AllegroEventSource

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_state_flags).</em>
  #
  # === Options:
  # :allegro_state_new_display_parameters ::
  #
  # :allegro_state_new_bitmap_parameters ::
  #
  # :allegro_state_display ::
  #
  # :allegro_state_target_bitmap ::
  #
  # :allegro_state_blender ::
  #
  # :allegro_state_new_file_interface ::
  #
  # :allegro_state_transform ::
  #
  # :allegro_state_all ::
  #
  #
  # @method _enum_allegro_state_flags_
  # @return [Symbol]
  # @scope class
  enum :allegro_state_flags, [
    :allegro_state_new_display_parameters, 1,
    :allegro_state_new_bitmap_parameters, 2,
    :allegro_state_display, 4,
    :allegro_state_target_bitmap, 8,
    :allegro_state_blender, 16,
    :allegro_state_new_file_interface, 32,
    :allegro_state_transform, 64,
    :allegro_state_all, 65535
  ]

  # (Not documented)
  #
  # = Fields:
  # :tls ::
  #   (Array<Integer>) Internally, a thread_local_state structure is placed here.
  class AllegroState < FFI::Struct
    layout :tls, [:char, 1024]
  end

  # (Not documented)
  #
  # @method al_store_state(state, flags)
  # @param [AllegroState] state
  # @param [Integer] flags
  # @return [nil]
  # @scope class
  attach_function :al_store_state, :al_store_state, [AllegroState, :int], :void

  # (Not documented)
  #
  # @method al_restore_state(state)
  # @param [AllegroState] state
  # @return [nil]
  # @scope class
  attach_function :al_restore_state, :al_restore_state, [AllegroState], :void

  # (Not documented)
  #
  # = Fields:
  # :m ::
  #   (Array<Array<Float>>)
  class AllegroTransform < FFI::Struct
    layout :m, [[:float, 4], 4]
  end

  # Transformations
  #
  # @method al_use_transform(trans)
  # @param [AllegroTransform] trans
  # @return [nil]
  # @scope class
  attach_function :al_use_transform, :al_use_transform, [AllegroTransform], :void

  # (Not documented)
  #
  # @method al_copy_transform(dest, src)
  # @param [AllegroTransform] dest
  # @param [AllegroTransform] src
  # @return [nil]
  # @scope class
  attach_function :al_copy_transform, :al_copy_transform, [AllegroTransform, AllegroTransform], :void

  # (Not documented)
  #
  # @method al_identity_transform(trans)
  # @param [AllegroTransform] trans
  # @return [nil]
  # @scope class
  attach_function :al_identity_transform, :al_identity_transform, [AllegroTransform], :void

  # (Not documented)
  #
  # @method al_build_transform(trans, x, y, sx, sy, theta)
  # @param [AllegroTransform] trans
  # @param [Float] x
  # @param [Float] y
  # @param [Float] sx
  # @param [Float] sy
  # @param [Float] theta
  # @return [nil]
  # @scope class
  attach_function :al_build_transform, :al_build_transform, [AllegroTransform, :float, :float, :float, :float, :float], :void

  # (Not documented)
  #
  # @method al_translate_transform(trans, x, y)
  # @param [AllegroTransform] trans
  # @param [Float] x
  # @param [Float] y
  # @return [nil]
  # @scope class
  attach_function :al_translate_transform, :al_translate_transform, [AllegroTransform, :float, :float], :void

  # (Not documented)
  #
  # @method al_rotate_transform(trans, theta)
  # @param [AllegroTransform] trans
  # @param [Float] theta
  # @return [nil]
  # @scope class
  attach_function :al_rotate_transform, :al_rotate_transform, [AllegroTransform, :float], :void

  # (Not documented)
  #
  # @method al_scale_transform(trans, sx, sy)
  # @param [AllegroTransform] trans
  # @param [Float] sx
  # @param [Float] sy
  # @return [nil]
  # @scope class
  attach_function :al_scale_transform, :al_scale_transform, [AllegroTransform, :float, :float], :void

  # (Not documented)
  #
  # @method al_transform_coordinates(trans, x, y)
  # @param [AllegroTransform] trans
  # @param [FFI::Pointer(*Float)] x
  # @param [FFI::Pointer(*Float)] y
  # @return [nil]
  # @scope class
  attach_function :al_transform_coordinates, :al_transform_coordinates, [AllegroTransform, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_compose_transform(trans, other)
  # @param [AllegroTransform] trans
  # @param [AllegroTransform] other
  # @return [nil]
  # @scope class
  attach_function :al_compose_transform, :al_compose_transform, [AllegroTransform, AllegroTransform], :void

  # (Not documented)
  #
  # @method al_get_current_transform()
  # @return [AllegroTransform]
  # @scope class
  attach_function :al_get_current_transform, :al_get_current_transform, [], AllegroTransform

  # (Not documented)
  #
  # @method al_invert_transform(trans)
  # @param [AllegroTransform] trans
  # @return [nil]
  # @scope class
  attach_function :al_invert_transform, :al_invert_transform, [AllegroTransform], :void

  # (Not documented)
  #
  # @method al_check_inverse(trans, tol)
  # @param [AllegroTransform] trans
  # @param [Float] tol
  # @return [Integer]
  # @scope class
  attach_function :al_check_inverse, :al_check_inverse, [AllegroTransform, :float], :int

  # (Not documented)
  #
  # = Fields:
  # :data ::
  #   (FFI::Pointer(*Void))
  # :height ::
  #   (Integer)
  # :vtable ::
  #   (FFI::Pointer(*AllegroFontVtable))
  class AllegroFont < FFI::Struct
    layout :data, :pointer,
           :height, :int,
           :vtable, :pointer
  end

  # (Not documented)
  #
  # = Fields:
  # :font_height ::
  #   (FFI::Pointer(*))
  # :font_ascent ::
  #   (FFI::Pointer(*))
  # :font_descent ::
  #   (FFI::Pointer(*))
  # :char_length ::
  #   (FFI::Pointer(*))
  # :text_length ::
  #   (FFI::Pointer(*))
  # :render_char ::
  #   (FFI::Pointer(*))
  # :render ::
  #   (FFI::Pointer(*))
  # :destroy ::
  #   (FFI::Pointer(*))
  # :get_text_dimensions ::
  #   (FFI::Pointer(*))
  class AllegroFontVtable < FFI::Struct
    layout :font_height, :pointer,
           :font_ascent, :pointer,
           :font_descent, :pointer,
           :char_length, :pointer,
           :text_length, :pointer,
           :render_char, :pointer,
           :render, :pointer,
           :destroy, :pointer,
           :get_text_dimensions, :pointer
  end

  # (Not documented)
  #
  # @method al_register_font_loader(ext, load)
  # @param [String] ext
  # @param [FFI::Pointer(*)] load
  # @return [Boolean]
  # @scope class
  attach_function :al_register_font_loader, :al_register_font_loader, [:string, :pointer], :bool

  # (Not documented)
  #
  # @method al_load_bitmap_font(filename)
  # @param [String] filename
  # @return [AllegroFont]
  # @scope class
  attach_function :al_load_bitmap_font, :al_load_bitmap_font, [:string], AllegroFont

  # (Not documented)
  #
  # @method al_load_font(filename, size, flags)
  # @param [String] filename
  # @param [Integer] size
  # @param [Integer] flags
  # @return [AllegroFont]
  # @scope class
  attach_function :al_load_font, :al_load_font, [:string, :int, :int], AllegroFont

  # (Not documented)
  #
  # @method al_grab_font_from_bitmap(bmp, n, ranges)
  # @param [AllegroBitmap] bmp
  # @param [Integer] n
  # @param [FFI::Pointer(*Int)] ranges
  # @return [AllegroFont]
  # @scope class
  attach_function :al_grab_font_from_bitmap, :al_grab_font_from_bitmap, [AllegroBitmap, :int, :pointer], AllegroFont

  # (Not documented)
  #
  # @method al_create_builtin_font()
  # @return [AllegroFont]
  # @scope class
  attach_function :al_create_builtin_font, :al_create_builtin_font, [], AllegroFont

  # (Not documented)
  #
  # @method al_draw_ustr(font, color, x, y, flags, ustr)
  # @param [AllegroFont] font
  # @param [AllegroColor] color
  # @param [Float] x
  # @param [Float] y
  # @param [Integer] flags
  # @param [AlTagbstring] ustr
  # @return [nil]
  # @scope class
  attach_function :al_draw_ustr, :al_draw_ustr, [AllegroFont, AllegroColor.by_value, :float, :float, :int, AlTagbstring], :void

  # (Not documented)
  #
  # @method al_draw_text(font, color, x, y, flags, text)
  # @param [AllegroFont] font
  # @param [AllegroColor] color
  # @param [Float] x
  # @param [Float] y
  # @param [Integer] flags
  # @param [String] text
  # @return [nil]
  # @scope class
  attach_function :al_draw_text, :al_draw_text, [AllegroFont, AllegroColor.by_value, :float, :float, :int, :string], :void

  # (Not documented)
  #
  # @method al_draw_justified_text(font, color, x1, x2, y, diff, flags, text)
  # @param [AllegroFont] font
  # @param [AllegroColor] color
  # @param [Float] x1
  # @param [Float] x2
  # @param [Float] y
  # @param [Float] diff
  # @param [Integer] flags
  # @param [String] text
  # @return [nil]
  # @scope class
  attach_function :al_draw_justified_text, :al_draw_justified_text, [AllegroFont, AllegroColor.by_value, :float, :float, :float, :float, :int, :string], :void

  # (Not documented)
  #
  # @method al_draw_justified_ustr(font, color, x1, x2, y, diff, flags, text)
  # @param [AllegroFont] font
  # @param [AllegroColor] color
  # @param [Float] x1
  # @param [Float] x2
  # @param [Float] y
  # @param [Float] diff
  # @param [Integer] flags
  # @param [AlTagbstring] text
  # @return [nil]
  # @scope class
  attach_function :al_draw_justified_ustr, :al_draw_justified_ustr, [AllegroFont, AllegroColor.by_value, :float, :float, :float, :float, :int, AlTagbstring], :void

  # (Not documented)
  #
  # @method al_draw_textf(font, color, x, y, flags, format)
  # @param [AllegroFont] font
  # @param [AllegroColor] color
  # @param [Float] x
  # @param [Float] y
  # @param [Integer] flags
  # @param [String] format
  # @return [nil]
  # @scope class
  attach_function :al_draw_textf, :al_draw_textf, [AllegroFont, AllegroColor.by_value, :float, :float, :int, :string], :void

  # (Not documented)
  #
  # @method al_draw_justified_textf(font, color, x1, x2, y, diff, flags, format)
  # @param [AllegroFont] font
  # @param [AllegroColor] color
  # @param [Float] x1
  # @param [Float] x2
  # @param [Float] y
  # @param [Float] diff
  # @param [Integer] flags
  # @param [String] format
  # @return [nil]
  # @scope class
  attach_function :al_draw_justified_textf, :al_draw_justified_textf, [AllegroFont, AllegroColor.by_value, :float, :float, :float, :float, :int, :string], :void

  # (Not documented)
  #
  # @method al_get_text_width(f, str)
  # @param [AllegroFont] f
  # @param [String] str
  # @return [Integer]
  # @scope class
  attach_function :al_get_text_width, :al_get_text_width, [AllegroFont, :string], :int

  # (Not documented)
  #
  # @method al_get_ustr_width(f, ustr)
  # @param [AllegroFont] f
  # @param [AlTagbstring] ustr
  # @return [Integer]
  # @scope class
  attach_function :al_get_ustr_width, :al_get_ustr_width, [AllegroFont, AlTagbstring], :int

  # (Not documented)
  #
  # @method al_get_font_line_height(f)
  # @param [AllegroFont] f
  # @return [Integer]
  # @scope class
  attach_function :al_get_font_line_height, :al_get_font_line_height, [AllegroFont], :int

  # (Not documented)
  #
  # @method al_get_font_ascent(f)
  # @param [AllegroFont] f
  # @return [Integer]
  # @scope class
  attach_function :al_get_font_ascent, :al_get_font_ascent, [AllegroFont], :int

  # (Not documented)
  #
  # @method al_get_font_descent(f)
  # @param [AllegroFont] f
  # @return [Integer]
  # @scope class
  attach_function :al_get_font_descent, :al_get_font_descent, [AllegroFont], :int

  # (Not documented)
  #
  # @method al_destroy_font(f)
  # @param [AllegroFont] f
  # @return [nil]
  # @scope class
  attach_function :al_destroy_font, :al_destroy_font, [AllegroFont], :void

  # (Not documented)
  #
  # @method al_get_ustr_dimensions(f, text, bbx, bby, bbw, bbh)
  # @param [AllegroFont] f
  # @param [AlTagbstring] text
  # @param [FFI::Pointer(*Int)] bbx
  # @param [FFI::Pointer(*Int)] bby
  # @param [FFI::Pointer(*Int)] bbw
  # @param [FFI::Pointer(*Int)] bbh
  # @return [nil]
  # @scope class
  attach_function :al_get_ustr_dimensions, :al_get_ustr_dimensions, [AllegroFont, AlTagbstring, :pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_get_text_dimensions(f, text, bbx, bby, bbw, bbh)
  # @param [AllegroFont] f
  # @param [String] text
  # @param [FFI::Pointer(*Int)] bbx
  # @param [FFI::Pointer(*Int)] bby
  # @param [FFI::Pointer(*Int)] bbw
  # @param [FFI::Pointer(*Int)] bbh
  # @return [nil]
  # @scope class
  attach_function :al_get_text_dimensions, :al_get_text_dimensions, [AllegroFont, :string, :pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_init_font_addon()
  # @return [nil]
  # @scope class
  attach_function :al_init_font_addon, :al_init_font_addon, [], :void

  # (Not documented)
  #
  # @method al_shutdown_font_addon()
  # @return [nil]
  # @scope class
  attach_function :al_shutdown_font_addon, :al_shutdown_font_addon, [], :void

  # (Not documented)
  #
  # @method al_get_allegro_font_version()
  # @return [Integer]
  # @scope class
  attach_function :al_get_allegro_font_version, :al_get_allegro_font_version, [], :uint

  # (Not documented)
  #
  # @method al_init_image_addon()
  # @return [Boolean]
  # @scope class
  attach_function :al_init_image_addon, :al_init_image_addon, [], :bool

  # (Not documented)
  #
  # @method al_shutdown_image_addon()
  # @return [nil]
  # @scope class
  attach_function :al_shutdown_image_addon, :al_shutdown_image_addon, [], :void

  # (Not documented)
  #
  # @method al_get_allegro_image_version()
  # @return [Integer]
  # @scope class
  attach_function :al_get_allegro_image_version, :al_get_allegro_image_version, [], :uint

  # (Not documented)
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_prim_type).</em>
  #
  # === Options:
  # :allegro_prim_line_list ::
  #
  # :allegro_prim_line_strip ::
  #
  # :allegro_prim_line_loop ::
  #
  # :allegro_prim_triangle_list ::
  #
  # :allegro_prim_triangle_strip ::
  #
  # :allegro_prim_triangle_fan ::
  #
  # :allegro_prim_point_list ::
  #
  # :allegro_prim_num_types ::
  #
  #
  # @method _enum_allegro_prim_type_
  # @return [Symbol]
  # @scope class
  enum :allegro_prim_type, [
    :allegro_prim_line_list, 0,
    :allegro_prim_line_strip, 1,
    :allegro_prim_line_loop, 2,
    :allegro_prim_triangle_list, 3,
    :allegro_prim_triangle_strip, 4,
    :allegro_prim_triangle_fan, 5,
    :allegro_prim_point_list, 6,
    :allegro_prim_num_types, 7
  ]

  # Enum: ALLEGRO_PRIM_ATTR
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_prim_attr).</em>
  #
  # === Options:
  # :allegro_prim_position ::
  #
  # :allegro_prim_color_attr ::
  #
  # :allegro_prim_tex_coord ::
  #
  # :allegro_prim_tex_coord_pixel ::
  #
  # :allegro_prim_attr_num ::
  #
  #
  # @method _enum_allegro_prim_attr_
  # @return [Symbol]
  # @scope class
  enum :allegro_prim_attr, [
    :allegro_prim_position, 1,
    :allegro_prim_color_attr, 2,
    :allegro_prim_tex_coord, 3,
    :allegro_prim_tex_coord_pixel, 4,
    :allegro_prim_attr_num, 5
  ]

  # Enum: ALLEGRO_PRIM_STORAGE
  #
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:allegro_prim_storage).</em>
  #
  # === Options:
  # :allegro_prim_float_2 ::
  #
  # :allegro_prim_float_3 ::
  #
  # :allegro_prim_short_2 ::
  #
  #
  # @method _enum_allegro_prim_storage_
  # @return [Symbol]
  # @scope class
  enum :allegro_prim_storage, [
    :allegro_prim_float_2, 0,
    :allegro_prim_float_3, 1,
    :allegro_prim_short_2, 2
  ]

  # Type: ALLEGRO_VERTEX_ELEMENT
  #
  # = Fields:
  # :attribute ::
  #   (Integer)
  # :storage ::
  #   (Integer)
  # :offset ::
  #   (Integer)
  class AllegroVertexElement < FFI::Struct
    layout :attribute, :int,
           :storage, :int,
           :offset, :int
  end

  # Type: ALLEGRO_VERTEX_DECL
  class AllegroVertexDecl < FFI::Struct
    layout :dummy, :char
  end

  # Type: ALLEGRO_VERTEX
  #
  # = Fields:
  # :x ::
  #   (Float)
  # :y ::
  #   (Float)
  # :z ::
  #   (Float)
  # :u ::
  #   (Float)
  # :v ::
  #   (Float)
  # :color ::
  #   (AllegroColor)
  class AllegroVertex < FFI::Struct
    layout :x, :float,
           :y, :float,
           :z, :float,
           :u, :float,
           :v, :float,
           :color, AllegroColor.by_value
  end

  # (Not documented)
  #
  # @method al_get_allegro_primitives_version()
  # @return [Integer]
  # @scope class
  attach_function :al_get_allegro_primitives_version, :al_get_allegro_primitives_version, [], :uint

  # Primary Functions
  #
  # @method al_init_primitives_addon()
  # @return [Boolean]
  # @scope class
  attach_function :al_init_primitives_addon, :al_init_primitives_addon, [], :bool

  # (Not documented)
  #
  # @method al_shutdown_primitives_addon()
  # @return [nil]
  # @scope class
  attach_function :al_shutdown_primitives_addon, :al_shutdown_primitives_addon, [], :void

  # (Not documented)
  #
  # @method al_draw_prim(vtxs, decl, texture, start, end_, type)
  # @param [FFI::Pointer(*Void)] vtxs
  # @param [AllegroVertexDecl] decl
  # @param [AllegroBitmap] texture
  # @param [Integer] start
  # @param [Integer] end_
  # @param [Integer] type
  # @return [Integer]
  # @scope class
  attach_function :al_draw_prim, :al_draw_prim, [:pointer, AllegroVertexDecl, AllegroBitmap, :int, :int, :int], :int

  # (Not documented)
  #
  # @method al_draw_indexed_prim(vtxs, decl, texture, indices, num_vtx, type)
  # @param [FFI::Pointer(*Void)] vtxs
  # @param [AllegroVertexDecl] decl
  # @param [AllegroBitmap] texture
  # @param [FFI::Pointer(*Int)] indices
  # @param [Integer] num_vtx
  # @param [Integer] type
  # @return [Integer]
  # @scope class
  attach_function :al_draw_indexed_prim, :al_draw_indexed_prim, [:pointer, AllegroVertexDecl, AllegroBitmap, :pointer, :int, :int], :int

  # (Not documented)
  #
  # @method al_create_vertex_decl(elements, stride)
  # @param [AllegroVertexElement] elements
  # @param [Integer] stride
  # @return [AllegroVertexDecl]
  # @scope class
  attach_function :al_create_vertex_decl, :al_create_vertex_decl, [AllegroVertexElement, :int], AllegroVertexDecl

  # (Not documented)
  #
  # @method al_destroy_vertex_decl(decl)
  # @param [AllegroVertexDecl] decl
  # @return [nil]
  # @scope class
  attach_function :al_destroy_vertex_decl, :al_destroy_vertex_decl, [AllegroVertexDecl], :void

  # Custom primitives
  #
  # @method al_draw_soft_triangle(v1, v2, v3, state, init, first, step, draw)
  # @param [AllegroVertex] v1
  # @param [AllegroVertex] v2
  # @param [AllegroVertex] v3
  # @param [Integer] state
  # @param [FFI::Pointer(*)] init
  # @param [FFI::Pointer(*)] first
  # @param [FFI::Pointer(*)] step
  # @param [FFI::Pointer(*)] draw
  # @return [nil]
  # @scope class
  attach_function :al_draw_soft_triangle, :al_draw_soft_triangle, [AllegroVertex, AllegroVertex, AllegroVertex, :ulong, :pointer, :pointer, :pointer, :pointer], :void

  # (Not documented)
  #
  # @method al_draw_soft_line(v1, v2, state, first, step, draw)
  # @param [AllegroVertex] v1
  # @param [AllegroVertex] v2
  # @param [Integer] state
  # @param [FFI::Pointer(*)] first
  # @param [FFI::Pointer(*)] step
  # @param [FFI::Pointer(*)] draw
  # @return [nil]
  # @scope class
  attach_function :al_draw_soft_line, :al_draw_soft_line, [AllegroVertex, AllegroVertex, :ulong, :pointer, :pointer, :pointer], :void

  # High level primitives
  #
  # @method al_draw_line(x1, y1, x2, y2, color, thickness)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_line, :al_draw_line, [:float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_triangle(x1, y1, x2, y2, x3, y3, color, thickness)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [Float] x3
  # @param [Float] y3
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_triangle, :al_draw_triangle, [:float, :float, :float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_rectangle(x1, y1, x2, y2, color, thickness)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_rectangle, :al_draw_rectangle, [:float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_rounded_rectangle(x1, y1, x2, y2, rx, ry, color, thickness)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [Float] rx
  # @param [Float] ry
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_rounded_rectangle, :al_draw_rounded_rectangle, [:float, :float, :float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_calculate_arc(dest, stride, cx, cy, rx, ry, start_theta, delta_theta, thickness, num_points)
  # @param [FFI::Pointer(*Float)] dest
  # @param [Integer] stride
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] rx
  # @param [Float] ry
  # @param [Float] start_theta
  # @param [Float] delta_theta
  # @param [Float] thickness
  # @param [Integer] num_points
  # @return [nil]
  # @scope class
  attach_function :al_calculate_arc, :al_calculate_arc, [:pointer, :int, :float, :float, :float, :float, :float, :float, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_circle(cx, cy, r, color, thickness)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] r
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_circle, :al_draw_circle, [:float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_ellipse(cx, cy, rx, ry, color, thickness)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] rx
  # @param [Float] ry
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_ellipse, :al_draw_ellipse, [:float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_arc(cx, cy, r, start_theta, delta_theta, color, thickness)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] r
  # @param [Float] start_theta
  # @param [Float] delta_theta
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_arc, :al_draw_arc, [:float, :float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_elliptical_arc(cx, cy, rx, ry, start_theta, delta_theta, color, thickness)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] rx
  # @param [Float] ry
  # @param [Float] start_theta
  # @param [Float] delta_theta
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_elliptical_arc, :al_draw_elliptical_arc, [:float, :float, :float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_draw_pieslice(cx, cy, r, start_theta, delta_theta, color, thickness)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] r
  # @param [Float] start_theta
  # @param [Float] delta_theta
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_pieslice, :al_draw_pieslice, [:float, :float, :float, :float, :float, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_calculate_spline(dest, stride, points, thickness, num_segments)
  # @param [FFI::Pointer(*Float)] dest
  # @param [Integer] stride
  # @param [Array<Float>] points
  # @param [Float] thickness
  # @param [Integer] num_segments
  # @return [nil]
  # @scope class
  attach_function :al_calculate_spline, :al_calculate_spline, [:pointer, :int, :pointer, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_spline(points, color, thickness)
  # @param [Array<Float>] points
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @return [nil]
  # @scope class
  attach_function :al_draw_spline, :al_draw_spline, [:pointer, AllegroColor.by_value, :float], :void

  # (Not documented)
  #
  # @method al_calculate_ribbon(dest, dest_stride, points, points_stride, thickness, num_segments)
  # @param [FFI::Pointer(*Float)] dest
  # @param [Integer] dest_stride
  # @param [FFI::Pointer(*Float)] points
  # @param [Integer] points_stride
  # @param [Float] thickness
  # @param [Integer] num_segments
  # @return [nil]
  # @scope class
  attach_function :al_calculate_ribbon, :al_calculate_ribbon, [:pointer, :int, :pointer, :int, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_ribbon(points, points_stride, color, thickness, num_segments)
  # @param [FFI::Pointer(*Float)] points
  # @param [Integer] points_stride
  # @param [AllegroColor] color
  # @param [Float] thickness
  # @param [Integer] num_segments
  # @return [nil]
  # @scope class
  attach_function :al_draw_ribbon, :al_draw_ribbon, [:pointer, :int, AllegroColor.by_value, :float, :int], :void

  # (Not documented)
  #
  # @method al_draw_filled_triangle(x1, y1, x2, y2, x3, y3, color)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [Float] x3
  # @param [Float] y3
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_filled_triangle, :al_draw_filled_triangle, [:float, :float, :float, :float, :float, :float, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_draw_filled_rectangle(x1, y1, x2, y2, color)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_filled_rectangle, :al_draw_filled_rectangle, [:float, :float, :float, :float, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_draw_filled_ellipse(cx, cy, rx, ry, color)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] rx
  # @param [Float] ry
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_filled_ellipse, :al_draw_filled_ellipse, [:float, :float, :float, :float, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_draw_filled_circle(cx, cy, r, color)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] r
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_filled_circle, :al_draw_filled_circle, [:float, :float, :float, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_draw_filled_pieslice(cx, cy, r, start_theta, delta_theta, color)
  # @param [Float] cx
  # @param [Float] cy
  # @param [Float] r
  # @param [Float] start_theta
  # @param [Float] delta_theta
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_filled_pieslice, :al_draw_filled_pieslice, [:float, :float, :float, :float, :float, AllegroColor.by_value], :void

  # (Not documented)
  #
  # @method al_draw_filled_rounded_rectangle(x1, y1, x2, y2, rx, ry, color)
  # @param [Float] x1
  # @param [Float] y1
  # @param [Float] x2
  # @param [Float] y2
  # @param [Float] rx
  # @param [Float] ry
  # @param [AllegroColor] color
  # @return [nil]
  # @scope class
  attach_function :al_draw_filled_rounded_rectangle, :al_draw_filled_rounded_rectangle, [:float, :float, :float, :float, :float, :float, AllegroColor.by_value], :void

end